/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WhereDidTheTimeGoPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  timeTrackingFolder: "TimeTracking",
  billFrom: {
    name: "",
    address: ""
  },
  invoiceFolder: "TimeTracking/Invoices",
  hourHeight: 200,
  dayStartHour: 6,
  dayEndHour: 22,
  defaultProject: "",
  use24HourFormat: true,
  weekStart: "monday",
  autoCreateFolder: true,
  descriptionMaxLength: 200,
  clients: [
    {
      id: "personal",
      name: "Personal",
      color: "#4f46e5",
      archived: false,
      rate: 0,
      currency: "USD",
      paymentTerms: "N/A"
    }
  ],
  projects: [
    { id: "default", name: "Default", color: "#4f46e5", archived: false, clientId: "personal" }
  ],
  activities: [],
  defaultActivity: "",
  debugMode: false,
  hideTablesInPreview: true
};
var VIEW_TYPE_TIMELINE = "where-did-the-time-go-timeline";
var VIEW_TYPE_REPORTS = "where-did-the-time-go-reports";

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/modals/ClientModal.ts
var import_obsidian = require("obsidian");
var ClientModal = class extends import_obsidian.Modal {
  constructor(app, data, onSave, onDelete) {
    super(app);
    this.data = data;
    this.onSave = onSave;
    this.onDelete = onDelete;
    if (data.mode === "edit" && data.client) {
      this.nameValue = data.client.name;
      this.colorValue = data.client.color;
      this.rateValue = data.client.rate;
      this.currencyValue = data.client.currency;
      this.addressValue = data.client.address || "";
      this.emailValue = data.client.email || "";
      this.taxIdValue = data.client.taxId || "";
      this.paymentTermsValue = data.client.paymentTerms || "";
      this.notesValue = data.client.notes || "";
    } else {
      this.nameValue = "";
      this.colorValue = this.getRandomColor();
      this.rateValue = 100;
      this.currencyValue = "USD";
      this.addressValue = "";
      this.emailValue = "";
      this.taxIdValue = "";
      this.paymentTermsValue = "Net 30";
      this.notesValue = "";
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("client-modal");
    contentEl.createEl("h2", {
      text: this.data.mode === "edit" ? "Edit Client" : "Add Client"
    });
    new import_obsidian.Setting(contentEl).setName("Client Name").setDesc("Display name for this client").addText((text5) => text5.setPlaceholder("Acme Corp").setValue(this.nameValue).onChange((value) => {
      this.nameValue = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Color").setDesc("Color for UI display").addColorPicker((picker) => picker.setValue(this.colorValue).onChange((value) => {
      this.colorValue = value;
    }));
    contentEl.createEl("h3", { text: "Billing" });
    new import_obsidian.Setting(contentEl).setName("Rate").setDesc("Billing rate for this client").addText((text5) => text5.setPlaceholder("100").setValue(this.rateValue.toString()).onChange((value) => {
      const num = parseFloat(value);
      if (!isNaN(num) && num >= 0) {
        this.rateValue = num;
      }
    }));
    new import_obsidian.Setting(contentEl).setName("Currency").setDesc("Currency code").addDropdown((dropdown) => dropdown.addOption("USD", "USD - US Dollar").addOption("EUR", "EUR - Euro").addOption("GBP", "GBP - British Pound").addOption("CAD", "CAD - Canadian Dollar").addOption("AUD", "AUD - Australian Dollar").addOption("JPY", "JPY - Japanese Yen").addOption("CHF", "CHF - Swiss Franc").addOption("INR", "INR - Indian Rupee").setValue(this.currencyValue).onChange((value) => {
      this.currencyValue = value;
    }));
    contentEl.createEl("h3", { text: "Invoice Details" });
    new import_obsidian.Setting(contentEl).setName("Billing Address").setDesc("Multi-line address for invoices").addTextArea((textarea) => textarea.setPlaceholder("123 Main Street\nSuite 400\nSan Francisco, CA 94102").setValue(this.addressValue).onChange((value) => {
      this.addressValue = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Email").setDesc("Invoice recipient email").addText((text5) => text5.setPlaceholder("billing@example.com").setValue(this.emailValue).onChange((value) => {
      this.emailValue = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Tax ID").setDesc("VAT number or tax ID").addText((text5) => text5.setPlaceholder("VAT123456789").setValue(this.taxIdValue).onChange((value) => {
      this.taxIdValue = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Payment Terms").setDesc("When payment is due").addDropdown((dropdown) => dropdown.addOption("Due on receipt", "Due on receipt").addOption("Net 15", "Net 15").addOption("Net 30", "Net 30").addOption("Net 45", "Net 45").addOption("Net 60", "Net 60").setValue(this.paymentTermsValue).onChange((value) => {
      this.paymentTermsValue = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Notes").setDesc("Internal notes about this client").addTextArea((textarea) => textarea.setPlaceholder("Optional internal notes...").setValue(this.notesValue).onChange((value) => {
      this.notesValue = value;
    }));
    const buttonRow = contentEl.createDiv("modal-button-row");
    if (this.data.mode === "edit" && this.onDelete) {
      const deleteBtn = buttonRow.createEl("button", {
        text: "Delete",
        cls: "mod-warning"
      });
      deleteBtn.addEventListener("click", () => {
        this.onDelete();
        this.close();
      });
    }
    buttonRow.createDiv("button-spacer");
    const cancelBtn = buttonRow.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonRow.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    saveBtn.addEventListener("click", () => this.handleSave());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  handleSave() {
    if (!this.nameValue.trim()) {
      new import_obsidian.Notice("Client name is required");
      return;
    }
    if (this.rateValue < 0) {
      new import_obsidian.Notice("Rate must be a positive number");
      return;
    }
    const client = {
      id: this.data.mode === "edit" && this.data.client ? this.data.client.id : this.slugify(this.nameValue),
      name: this.nameValue.trim(),
      color: this.colorValue,
      archived: this.data.mode === "edit" && this.data.client ? this.data.client.archived : false,
      rate: this.rateValue,
      currency: this.currencyValue,
      address: this.addressValue.trim() || void 0,
      email: this.emailValue.trim() || void 0,
      taxId: this.taxIdValue.trim() || void 0,
      paymentTerms: this.paymentTermsValue,
      notes: this.notesValue.trim() || void 0
    };
    this.onSave(client);
    this.close();
  }
  slugify(text5) {
    return text5.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
  }
  getRandomColor() {
    const colors = [
      "#4f46e5",
      // Indigo
      "#059669",
      // Emerald
      "#e11d48",
      // Rose
      "#f59e0b",
      // Amber
      "#8b5cf6",
      // Violet
      "#06b6d4",
      // Cyan
      "#84cc16",
      // Lime
      "#f97316"
      // Orange
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }
};

// src/settings.ts
var TimeTrackerSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.expandedClients = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Where Did The Time Go?" });
    containerEl.createEl("p", {
      text: "Configure your time tracking settings.",
      cls: "setting-item-description"
    });
    containerEl.createEl("h2", { text: "Storage" });
    new import_obsidian2.Setting(containerEl).setName("Time tracking folder").setDesc("Folder where time entries will be stored (relative to vault root)").addText((text5) => text5.setPlaceholder("TimeTracking").setValue(this.plugin.settings.timeTrackingFolder).onChange(async (value) => {
      this.plugin.settings.timeTrackingFolder = value || "TimeTracking";
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto-create folder").setDesc("Automatically create the time tracking folder if it doesn't exist").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCreateFolder).onChange(async (value) => {
      this.plugin.settings.autoCreateFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Hide tables in reading view").setDesc("Wrap data tables in %% comment markers to hide them in reading view. Disable to see raw table data.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideTablesInPreview).onChange(async (value) => {
      this.plugin.settings.hideTablesInPreview = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Timeline Display" });
    new import_obsidian2.Setting(containerEl).setName("Hour height").setDesc("Height in pixels for each hour in the timeline view").addSlider((slider) => slider.setLimits(200, 240, 10).setValue(this.plugin.settings.hourHeight).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.hourHeight = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Day start hour").setDesc("First hour to display in the timeline (0-23)").addDropdown((dropdown) => {
      for (let i = 0; i <= 12; i++) {
        dropdown.addOption(i.toString(), `${i}:00`);
      }
      dropdown.setValue(this.plugin.settings.dayStartHour.toString());
      dropdown.onChange(async (value) => {
        this.plugin.settings.dayStartHour = parseInt(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Day end hour").setDesc("Last hour to display in the timeline (0-23)").addDropdown((dropdown) => {
      for (let i = 18; i <= 24; i++) {
        dropdown.addOption(i.toString(), i === 24 ? "24:00 (midnight)" : `${i}:00`);
      }
      dropdown.setValue(this.plugin.settings.dayEndHour.toString());
      dropdown.onChange(async (value) => {
        this.plugin.settings.dayEndHour = parseInt(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("24-hour format").setDesc("Use 24-hour time format (e.g., 14:00) instead of 12-hour (e.g., 2:00 PM)").addToggle((toggle) => toggle.setValue(this.plugin.settings.use24HourFormat).onChange(async (value) => {
      this.plugin.settings.use24HourFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Description max length").setDesc("Maximum characters for entry descriptions (0 = no limit)").addText((text5) => text5.setValue(this.plugin.settings.descriptionMaxLength.toString()).setPlaceholder("200").onChange(async (value) => {
      const num = parseInt(value) || 0;
      this.plugin.settings.descriptionMaxLength = Math.max(0, num);
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Week start").setDesc("First day of the week").addDropdown((dropdown) => dropdown.addOption("monday", "Monday").addOption("sunday", "Sunday").setValue(this.plugin.settings.weekStart).onChange(async (value) => {
      this.plugin.settings.weekStart = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Bill From" });
    containerEl.createEl("p", {
      text: "Your billing information that appears on invoices.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Name").setDesc("Your name or business name").addText((text5) => text5.setPlaceholder("Your Name / Business Name").setValue(this.plugin.settings.billFrom.name).onChange(async (value) => {
      this.plugin.settings.billFrom.name = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Address").setDesc("Your billing address (multi-line)").addTextArea((textarea) => textarea.setPlaceholder("123 Main Street\nCity, State 12345\nCountry").setValue(this.plugin.settings.billFrom.address).onChange(async (value) => {
      this.plugin.settings.billFrom.address = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Invoice folder").setDesc("Folder where invoices will be saved (created automatically)").addText((text5) => text5.setPlaceholder("TimeTracking/Invoices").setValue(this.plugin.settings.invoiceFolder).onChange(async (value) => {
      this.plugin.settings.invoiceFolder = value || "TimeTracking/Invoices";
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Clients" });
    containerEl.createEl("p", {
      text: "Define clients for billing. Projects can be assigned to clients for invoicing.",
      cls: "setting-item-description"
    });
    const clientsContainer = containerEl.createDiv("clients-container");
    this.renderClientsList(clientsContainer);
    new import_obsidian2.Setting(containerEl).addButton((button) => button.setButtonText("Add Client").setCta().onClick(() => {
      const modal = new ClientModal(
        this.app,
        { mode: "create" },
        async (client) => {
          this.plugin.settings.clients.push(client);
          await this.plugin.saveSettings();
          this.renderClientsList(clientsContainer);
        }
      );
      modal.open();
    }));
    containerEl.createEl("h2", { text: "Developer" });
    new import_obsidian2.Setting(containerEl).setName("Debug mode").setDesc("Enable verbose logging to the developer console (useful for troubleshooting)").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
  }
  renderClientsList(container) {
    container.empty();
    if (this.plugin.settings.clients.length === 0) {
      container.createEl("p", {
        text: "No clients defined yet. Add a client to start tracking billable time.",
        cls: "setting-item-description"
      });
      return;
    }
    this.plugin.settings.clients.forEach((client, clientIndex) => {
      const isExpanded = this.expandedClients.has(client.id);
      const clientCard = container.createDiv("client-card");
      if (client.archived)
        clientCard.addClass("is-archived");
      const clientHeader = clientCard.createDiv("client-header");
      clientHeader.addEventListener("click", () => {
        if (isExpanded) {
          this.expandedClients.delete(client.id);
        } else {
          this.expandedClients.add(client.id);
        }
        this.renderClientsList(container);
      });
      const expandIcon = clientHeader.createSpan("client-expand-icon");
      expandIcon.setText(isExpanded ? "\u25BC" : "\u25B6");
      const colorDot = clientHeader.createSpan("client-color-dot");
      colorDot.style.backgroundColor = client.color;
      clientHeader.createSpan({ text: client.name, cls: "client-name" });
      const rateDisplay = `${client.currency} ${client.rate}/hr`;
      clientHeader.createSpan({ text: rateDisplay, cls: "client-rate-badge" });
      const editBtn = clientHeader.createEl("button", { cls: "client-edit-btn" });
      editBtn.setText("Edit");
      editBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const modal = new ClientModal(
          this.app,
          { mode: "edit", client },
          async (updatedClient) => {
            this.plugin.settings.clients[clientIndex] = updatedClient;
            await this.plugin.saveSettings();
            this.renderClientsList(container);
          },
          async () => {
            this.plugin.settings.projects = this.plugin.settings.projects.filter(
              (p) => p.clientId !== client.id
            );
            this.plugin.settings.activities = this.plugin.settings.activities.filter(
              (a) => a.clientId !== client.id
            );
            this.plugin.settings.clients.splice(clientIndex, 1);
            await this.plugin.saveSettings();
            this.renderClientsList(container);
          }
        );
        modal.open();
      });
      if (isExpanded) {
        const expandedContent = clientCard.createDiv("client-expanded");
        const projectsSection = expandedContent.createDiv("client-section");
        const projectsHeader = projectsSection.createDiv("client-section-header");
        projectsHeader.createSpan({ text: "Projects", cls: "client-section-title" });
        const addProjectBtn = projectsHeader.createEl("button", { text: "+ Add", cls: "client-add-btn" });
        addProjectBtn.addEventListener("click", async () => {
          const newProject = {
            id: `project-${Date.now()}`,
            name: "New Project",
            color: this.getRandomColor(),
            archived: false,
            clientId: client.id
          };
          this.plugin.settings.projects.push(newProject);
          await this.plugin.saveSettings();
          this.renderClientsList(container);
        });
        const clientProjects = this.plugin.settings.projects.filter((p) => p.clientId === client.id);
        if (clientProjects.length === 0) {
          projectsSection.createEl("p", { text: "No projects yet", cls: "client-empty-text" });
        } else {
          const projectsList = projectsSection.createDiv("client-items-list");
          clientProjects.forEach((project, projectIndex) => {
            const actualIndex = this.plugin.settings.projects.indexOf(project);
            this.renderProjectItem(projectsList, project, actualIndex, container);
          });
        }
        const activitiesSection = expandedContent.createDiv("client-section");
        const activitiesHeader = activitiesSection.createDiv("client-section-header");
        activitiesHeader.createSpan({ text: "Activities", cls: "client-section-title" });
        const addActivityBtn = activitiesHeader.createEl("button", { text: "+ Add", cls: "client-add-btn" });
        addActivityBtn.addEventListener("click", async () => {
          const newActivity = {
            id: `activity-${Date.now()}`,
            name: "New Activity",
            color: this.getRandomColor(),
            clientId: client.id
          };
          this.plugin.settings.activities.push(newActivity);
          await this.plugin.saveSettings();
          this.renderClientsList(container);
        });
        const clientActivities = this.plugin.settings.activities.filter((a) => a.clientId === client.id);
        if (clientActivities.length === 0) {
          activitiesSection.createEl("p", { text: "No activities yet", cls: "client-empty-text" });
        } else {
          const activitiesList = activitiesSection.createDiv("client-items-list");
          clientActivities.forEach((activity) => {
            const actualIndex = this.plugin.settings.activities.indexOf(activity);
            this.renderActivityItem(activitiesList, activity, actualIndex, container);
          });
        }
      }
    });
  }
  /**
   * Render a single project item within a client
   */
  renderProjectItem(container, project, index2, parentContainer) {
    const item = container.createDiv("client-item");
    if (project.archived)
      item.addClass("is-archived");
    const colorPicker = item.createEl("input", { type: "color", cls: "client-item-color" });
    colorPicker.value = project.color;
    colorPicker.addEventListener("change", async () => {
      project.color = colorPicker.value;
      await this.plugin.saveSettings();
    });
    const nameInput = item.createEl("input", { type: "text", cls: "client-item-name" });
    nameInput.value = project.name;
    nameInput.addEventListener("change", async () => {
      project.name = nameInput.value;
      project.id = this.slugify(nameInput.value);
      await this.plugin.saveSettings();
    });
    const archiveBtn = item.createEl("button", {
      text: project.archived ? "\u21A9" : "\u{1F4E6}",
      cls: "client-item-btn"
    });
    archiveBtn.title = project.archived ? "Unarchive" : "Archive";
    archiveBtn.addEventListener("click", async () => {
      project.archived = !project.archived;
      await this.plugin.saveSettings();
      this.renderClientsList(parentContainer);
    });
    const deleteBtn = item.createEl("button", { text: "\u{1F5D1}", cls: "client-item-btn" });
    deleteBtn.title = "Delete";
    deleteBtn.addEventListener("click", async () => {
      this.plugin.settings.projects.splice(index2, 1);
      await this.plugin.saveSettings();
      this.renderClientsList(parentContainer);
    });
  }
  /**
   * Render a single activity item within a client
   */
  renderActivityItem(container, activity, index2, parentContainer) {
    const item = container.createDiv("client-item");
    const colorPicker = item.createEl("input", { type: "color", cls: "client-item-color" });
    colorPicker.value = activity.color;
    colorPicker.addEventListener("change", async () => {
      activity.color = colorPicker.value;
      await this.plugin.saveSettings();
    });
    const nameInput = item.createEl("input", { type: "text", cls: "client-item-name" });
    nameInput.value = activity.name;
    nameInput.addEventListener("change", async () => {
      activity.name = nameInput.value;
      activity.id = this.slugify(nameInput.value);
      await this.plugin.saveSettings();
    });
    const deleteBtn = item.createEl("button", { text: "\u{1F5D1}", cls: "client-item-btn" });
    deleteBtn.title = "Delete";
    deleteBtn.addEventListener("click", async () => {
      this.plugin.settings.activities.splice(index2, 1);
      await this.plugin.saveSettings();
      this.renderClientsList(parentContainer);
    });
  }
  slugify(text5) {
    return text5.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
  }
  getRandomColor() {
    const colors = [
      "#4f46e5",
      // Indigo
      "#059669",
      // Emerald
      "#e11d48",
      // Rose
      "#f59e0b",
      // Amber
      "#8b5cf6",
      // Violet
      "#06b6d4",
      // Cyan
      "#84cc16",
      // Lime
      "#f97316"
      // Orange
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }
};

// src/data/DataManager.ts
var import_obsidian3 = require("obsidian");

// node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/devlop/lib/default.js
function ok() {
}

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point3) {
  return index(point3 && point3.line) + ":" + index(point3 && point3.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file = "";
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual = void 0;
    this.expected = void 0;
    this.note = void 0;
    this.url = void 0;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/vfile/lib/minpath.browser.js
var minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path2, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (extname2 === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extnameIndex > -1) {
        if (path2.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index2;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code3 = path2.codePointAt(index2);
    if (code3 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code3 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code3;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code3 = path2.codePointAt(index2);
    } else if (code3 === 47) {
      break;
    } else {
      code3 = 47;
    }
    if (code3 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code3 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// node_modules/vfile/lib/minproc.browser.js
var minproc = { cwd };
function cwd() {
  return "/";
}

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` â€” `{value: options}`
   * *   `URL` â€” `{path: options}`
   * *   `VFile` â€” shallow copies its data over to the new file
   * *   `object` â€” all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const field2 = order[index2];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâ€™s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
};
function assertPart(part, name) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/unified/lib/callable-instance.js
var CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self = this;
    const constr = self.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    return apply;
  }
);

// node_modules/unified/lib/index.js
var own = {}.hasOwnProperty;
var Processor = class extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self.parse(realFile)
      );
      self.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      ok(
        typeof file !== "function",
        "`file` can\u2019t be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const character = element.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}

// node_modules/micromark-util-chunked/index.js
function splice(list4, start, remove, items) {
  const end = list4.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list4.splice(...parameters);
  } else {
    if (remove)
      list4.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list4.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list4, items) {
  if (list4.length > 0) {
    splice(list4, list4.length, 0, items);
    return list4;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code3;
    if (right) {
      for (code3 in right) {
        if (!hasOwnProperty.call(left, code3))
          left[code3] = [];
        const value = right[code3];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code3],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list4) {
  let index2 = -1;
  const before = [];
  while (++index2 < list4.length) {
    ;
    (list4[index2].add === "after" ? existing : before).push(list4[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value, base) {
  const code3 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code3 < 9 || code3 === 11 || code3 > 13 && code3 < 32 || // Control character (DEL) of C0, and C1 controls.
    code3 > 126 && code3 < 160 || // Lone high surrogates and low surrogates.
    code3 > 55295 && code3 < 57344 || // Noncharacters.
    code3 > 64975 && code3 < 65008 || /* eslint-disable no-bitwise */
    (code3 & 65535) === 65535 || (code3 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code3 > 1114111
  ) {
    return "\uFFFD";
  }
  return String.fromCodePoint(code3);
}

// node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code3) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code3 !== null && (code3 < 32 || code3 === 127)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code3) {
  return code3 !== null && code3 < -2;
}
function markdownLineEndingOrSpace(code3) {
  return code3 !== null && (code3 < 0 || code3 === 32);
}
function markdownSpace(code3) {
  return code3 === -2 || code3 === -1 || code3 === 32;
}
var unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code3) {
    return code3 !== null && code3 > -1 && regex.test(String.fromCharCode(code3));
  }
}

// node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok3, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code3) {
    if (markdownSpace(code3)) {
      effects.enter(type);
      return prefix(code3);
    }
    return ok3(code3);
  }
  function prefix(code3) {
    if (markdownSpace(code3) && size++ < limit) {
      effects.consume(code3);
      return prefix;
    }
    effects.exit(type);
    return ok3(code3);
  }
}

// node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code3) {
    if (code3 === null) {
      effects.consume(code3);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code3) {
    effects.enter("paragraph");
    return lineStart(code3);
  }
  function lineStart(code3) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous3
    });
    if (previous3) {
      previous3.next = token;
    }
    previous3 = token;
    return data(code3);
  }
  function data(code3) {
    if (code3 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code3);
    return data;
  }
}

// node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code3) {
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code3);
    }
    return checkNewContainers(code3);
  }
  function documentContinue(code3) {
    continued++;
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point3;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          point3 = self.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = {
          ...point3
        };
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
      return checkNewContainers(code3);
    }
    return start(code3);
  }
  function checkNewContainers(code3) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code3);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code3);
      }
      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code3);
  }
  function thereIsANewContainer(code3) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code3);
  }
  function thereIsNoNewContainer(code3) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code3);
  }
  function documentContinued(code3) {
    self.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code3);
  }
  function containerContinue(code3) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    return documentContinued(code3);
  }
  function flowStart(code3) {
    if (code3 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter("chunkFlow", {
      _tokenizer: childFlow,
      contentType: "flow",
      previous: childToken
    });
    return flowContinue(code3);
  }
  function flowContinue(code3) {
    if (code3 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self.interrupt = void 0;
      return start;
    }
    effects.consume(code3);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    const stream = self.sliceStream(token);
    if (endOfFile)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line endingâ€¦
          childFlow.events[index2][1].start.offset < lineStartOffset && // â€¦and either is not ended yetâ€¦
          (!childFlow.events[index2][1].end || // â€¦or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point3;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point3 = self.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = {
          ...point3
        };
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok3, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code3) {
  if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
    return 1;
  }
  if (unicodePunctuation(code3)) {
    return 2;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text5;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = {
            ...events[open][1].end
          };
          const end = {
            ...events[index2][1].start
          };
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: {
              ...events[open][1].end
            }
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...events[index2][1].start
            },
            end
          };
          text5 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: {
              ...events[open][1].end
            },
            end: {
              ...events[index2][1].start
            }
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: {
              ...openingSequence.start
            },
            end: {
              ...closingSequence.end
            }
          };
          events[open][1].end = {
            ...openingSequence.start
          };
          events[index2][1].start = {
            ...closingSequence.end
          };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
          }
          nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text5, context]]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [["exit", text5, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start;
  function start(code3) {
    marker = code3;
    effects.enter("attentionSequence");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code3);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code3);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous3);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok3(code3);
  }
}
function movePoint(point3, offset) {
  point3.column += offset;
  point3.offset += offset;
  point3._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code3) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code3);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return schemeOrEmailAtext;
    }
    if (code3 === 64) {
      return nok(code3);
    }
    return emailAtext(code3);
  }
  function schemeOrEmailAtext(code3) {
    if (code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3)) {
      size = 1;
      return schemeInsideOrEmailAtext(code3);
    }
    return emailAtext(code3);
  }
  function schemeInsideOrEmailAtext(code3) {
    if (code3 === 58) {
      effects.consume(code3);
      size = 0;
      return urlInside;
    }
    if ((code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3)) && size++ < 32) {
      effects.consume(code3);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code3);
  }
  function urlInside(code3) {
    if (code3 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code3);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok3;
    }
    if (code3 === null || code3 === 32 || code3 === 60 || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return urlInside;
  }
  function emailAtext(code3) {
    if (code3 === 64) {
      effects.consume(code3);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code3)) {
      effects.consume(code3);
      return emailAtext;
    }
    return nok(code3);
  }
  function emailAtSignOrDot(code3) {
    return asciiAlphanumeric(code3) ? emailLabel(code3) : nok(code3);
  }
  function emailLabel(code3) {
    if (code3 === 46) {
      effects.consume(code3);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code3 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code3);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok3;
    }
    return emailValue(code3);
  }
  function emailValue(code3) {
    if ((code3 === 45 || asciiAlphanumeric(code3)) && size++ < 63) {
      const next = code3 === 45 ? emailValue : emailLabel;
      effects.consume(code3);
      return next;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  partial: true,
  tokenize: tokenizeBlankLine
};
function tokenizeBlankLine(effects, ok3, nok) {
  return start;
  function start(code3) {
    return markdownSpace(code3) ? factorySpace(effects, after, "linePrefix")(code3) : after(code3);
  }
  function after(code3) {
    return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code3) {
    if (code3 === 62) {
      const state = self.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code3);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownSpace(code3)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code3);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok3;
    }
    effects.exit("blockQuotePrefix");
    return ok3(code3);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self = this;
  return contStart;
  function contStart(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(effects, contBefore, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code3);
    }
    return contBefore(code3);
  }
  function contBefore(code3) {
    return effects.attempt(blockQuote, ok3, nok)(code3);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}

// node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start;
  function start(code3) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code3);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code3) {
    if (asciiPunctuation(code3)) {
      effects.enter("characterEscapeValue");
      effects.consume(code3);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code3) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code3);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code3) {
    if (code3 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code3);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code3);
  }
  function numeric(code3) {
    if (code3 === 88 || code3 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code3);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code3);
  }
  function value(code3) {
    if (code3 === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {
        return nok(code3);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code3);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok3;
    }
    if (test(code3) && size++ < max) {
      effects.consume(code3);
      return value;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self = this;
  const closeStart = {
    partial: true,
    tokenize: tokenizeCloseStart
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code3) {
    return beforeSequenceOpen(code3);
  }
  function beforeSequenceOpen(code3) {
    const tail = self.events[self.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code3;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === marker) {
      sizeOpen++;
      effects.consume(code3);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code3);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code3) ? factorySpace(effects, infoBefore, "whitespace")(code3) : infoBefore(code3);
  }
  function infoBefore(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("codeFencedFence");
      return self.interrupt ? ok3(code3) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code3);
  }
  function info(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code3);
    }
    if (code3 === 96 && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return info;
  }
  function metaBefore(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return infoBefore(code3);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code3);
  }
  function meta(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code3);
    }
    if (code3 === 96 && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return meta;
  }
  function atNonLazyBreak(code3) {
    return effects.attempt(closeStart, after, contentBefore)(code3);
  }
  function contentBefore(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code3) {
    return initialPrefix > 0 && markdownSpace(code3) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code3) : beforeContentChunk(code3);
  }
  function beforeContentChunk(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code3);
  }
  function contentChunk(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code3);
    }
    effects.consume(code3);
    return contentChunk;
  }
  function after(code3) {
    effects.exit("codeFenced");
    return ok3(code3);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code3) {
      effects2.enter("lineEnding");
      effects2.consume(code3);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code3) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code3) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code3) : beforeSequenceClose(code3);
    }
    function beforeSequenceClose(code3) {
      if (code3 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code3);
      }
      return nok2(code3);
    }
    function sequenceClose(code3) {
      if (code3 === marker) {
        size++;
        effects2.consume(code3);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code3) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code3) : sequenceCloseAfter(code3);
      }
      return nok2(code3);
    }
    function sequenceCloseAfter(code3) {
      if (code3 === null || markdownLineEnding(code3)) {
        effects2.exit("codeFencedFence");
        return ok4(code3);
      }
      return nok2(code3);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code3) {
    return self.parser.lazy[self.now().line] ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = {
  partial: true,
  tokenize: tokenizeFurtherStart
};
function tokenizeCodeIndented(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code3) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code3);
  }
  function afterPrefix(code3) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code3) : nok(code3);
  }
  function atBreak(code3) {
    if (code3 === null) {
      return after(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.attempt(furtherStart, atBreak, after)(code3);
    }
    effects.enter("codeFlowValue");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("codeFlowValue");
      return atBreak(code3);
    }
    effects.consume(code3);
    return inside;
  }
  function after(code3) {
    effects.exit("codeIndented");
    return ok3(code3);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self = this;
  return furtherStart2;
  function furtherStart2(code3) {
    if (self.parser.lazy[self.now().line]) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code3);
  }
  function afterPrefix(code3) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code3) : markdownLineEnding(code3) ? furtherStart2(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code3) {
  return code3 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok3, nok) {
  const self = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code3) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === 96) {
      effects.consume(code3);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between2(code3);
  }
  function between2(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 32) {
      effects.enter("space");
      effects.consume(code3);
      effects.exit("space");
      return between2;
    }
    if (code3 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return between2;
    }
    effects.enter("codeTextData");
    return data(code3);
  }
  function data(code3) {
    if (code3 === null || code3 === 32 || code3 === 96 || markdownLineEnding(code3)) {
      effects.exit("codeTextData");
      return between2(code3);
    }
    effects.consume(code3);
    return data;
  }
  function sequenceClose(code3) {
    if (code3 === 96) {
      effects.consume(code3);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok3(code3);
    }
    token.type = "codeTextData";
    return data(code3);
  }
}

// node_modules/micromark-util-subtokenize/lib/splice-buffer.js
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    }
    if (index2 < this.left.length)
      return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start, stop);
    }
    if (start > this.left.length) {
      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
    }
    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
    if (items)
      chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
      return;
    if (n < this.left.length) {
      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list4, right) {
  let chunkStart = 0;
  if (right.length < 1e4) {
    list4.push(...right);
  } else {
    while (chunkStart < right.length) {
      list4.push(...right.slice(chunkStart, chunkStart + 1e4));
      chunkStart += 1e4;
    }
  }
}

// node_modules/micromark-util-subtokenize/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") {
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = {
          ...events.get(lineIndex)[1].start
        };
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  let tokenizer = token._tokenizer;
  if (!tokenizer) {
    tokenizer = context.parser[token.contentType](token.start);
    if (token._contentTypeTextTrailing) {
      tokenizer._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous3) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.push([start2, start2 + slice.length - 1]);
    events.splice(start2, 2, slice);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  resolve: resolveContent,
  tokenize: tokenizeContent
};
var continuationConstruct = {
  partial: true,
  tokenize: tokenizeContinuation
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code3) {
    effects.enter("content");
    previous3 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code3);
  }
  function chunkInside(code3) {
    if (code3 === null) {
      return contentEnd(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code3);
    }
    effects.consume(code3);
    return chunkInside;
  }
  function contentEnd(code3) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok3(code3);
  }
  function contentContinue(code3) {
    effects.consume(code3);
    effects.exit("chunkContent");
    previous3.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self = this;
  return startLookahead;
  function startLookahead(code3) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return nok(code3);
    }
    const tail = self.events[self.events.length - 1];
    if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok3(code3);
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok3)(code3);
  }
}

// node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code3) {
    if (code3 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code3 === null || code3 === 32 || code3 === 41 || asciiControl(code3)) {
      return nok(code3);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code3);
  }
  function enclosedBefore(code3) {
    if (code3 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code3);
  }
  function enclosed(code3) {
    if (code3 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code3);
    }
    if (code3 === null || code3 === 60 || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code3) {
    if (code3 === 60 || code3 === 62 || code3 === 92) {
      effects.consume(code3);
      return enclosed;
    }
    return enclosed(code3);
  }
  function raw(code3) {
    if (!balance && (code3 === null || code3 === 41 || markdownLineEndingOrSpace(code3))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code3);
    }
    if (balance < limit && code3 === 40) {
      effects.consume(code3);
      balance++;
      return raw;
    }
    if (code3 === 41) {
      effects.consume(code3);
      balance--;
      return raw;
    }
    if (code3 === null || code3 === 32 || code3 === 40 || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? rawEscape : raw;
  }
  function rawEscape(code3) {
    if (code3 === 40 || code3 === 41 || code3 === 92) {
      effects.consume(code3);
      return raw;
    }
    return raw(code3);
  }
}

// node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self = this;
  let size = 0;
  let seen;
  return start;
  function start(code3) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code3) {
    if (size > 999 || code3 === null || code3 === 91 || code3 === 93 && !seen || // To do: remove in the future once weâ€™ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnâ€™t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code3 === 94 && !size && "_hiddenFootnoteSupport" in self.parser.constructs) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code3);
  }
  function labelInside(code3) {
    if (code3 === null || code3 === 91 || code3 === 93 || markdownLineEnding(code3) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code3);
    }
    effects.consume(code3);
    if (!seen)
      seen = !markdownSpace(code3);
    return code3 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === 91 || code3 === 92 || code3 === 93) {
      effects.consume(code3);
      size++;
      return labelInside;
    }
    return labelInside(code3);
  }
}

// node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code3) {
    if (code3 === 34 || code3 === 39 || code3 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      marker = code3 === 40 ? 41 : code3;
      return begin;
    }
    return nok(code3);
  }
  function begin(code3) {
    if (code3 === marker) {
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code3 === null) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker || code3 === null || markdownLineEnding(code3)) {
      effects.exit("chunkString");
      return atBreak(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? escape : inside;
  }
  function escape(code3) {
    if (code3 === marker || code3 === 92) {
      effects.consume(code3);
      return inside;
    }
    return inside(code3);
  }
}

// node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start;
  function start(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code3);
    }
    return ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleBefore = {
  partial: true,
  tokenize: tokenizeTitleBefore
};
function tokenizeDefinition(effects, ok3, nok) {
  const self = this;
  let identifier;
  return start;
  function start(code3) {
    effects.enter("definition");
    return before(code3);
  }
  function before(code3) {
    return factoryLabel.call(
      self,
      effects,
      labelAfter,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code3);
  }
  function labelAfter(code3) {
    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));
    if (code3 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code3);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code3);
  }
  function markerAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, destinationBefore)(code3) : destinationBefore(code3);
  }
  function destinationBefore(code3) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code3);
  }
  function destinationAfter(code3) {
    return effects.attempt(titleBefore, after, after)(code3);
  }
  function after(code3) {
    return markdownSpace(code3) ? factorySpace(effects, afterWhitespace, "whitespace")(code3) : afterWhitespace(code3);
  }
  function afterWhitespace(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("definition");
      self.parser.defined.push(identifier);
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, beforeMarker)(code3) : nok(code3);
  }
  function beforeMarker(code3) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code3);
  }
  function titleAfter(code3) {
    return markdownSpace(code3) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code3) : titleAfterOptionalWhitespace(code3);
  }
  function titleAfterOptionalWhitespace(code3) {
    return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start;
  function start(code3) {
    effects.enter("hardBreakEscape");
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      effects.exit("hardBreakEscape");
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text5;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text5 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content3, context], ["enter", text5, context], ["exit", text5, context], ["exit", content3, context]]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code3) {
    effects.enter("atxHeading");
    return before(code3);
  }
  function before(code3) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === 35 && size++ < 6) {
      effects.consume(code3);
      return sequenceOpen;
    }
    if (code3 === null || markdownLineEndingOrSpace(code3)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code3);
    }
    return nok(code3);
  }
  function atBreak(code3) {
    if (code3 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("atxHeading");
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, atBreak, "whitespace")(code3);
    }
    effects.enter("atxHeadingText");
    return data(code3);
  }
  function sequenceFurther(code3) {
    if (code3 === 35) {
      effects.consume(code3);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code3);
  }
  function data(code3) {
    if (code3 === null || code3 === 35 || markdownLineEndingOrSpace(code3)) {
      effects.exit("atxHeadingText");
      return atBreak(code3);
    }
    effects.consume(code3);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = {
  partial: true,
  tokenize: tokenizeBlankLineBefore
};
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code3) {
    return before(code3);
  }
  function before(code3) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === 33) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === 47) {
      effects.consume(code3);
      closingTag = true;
      return tagCloseStart;
    }
    if (code3 === 63) {
      effects.consume(code3);
      marker = 3;
      return self.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      marker = 2;
      return commentOpenInside;
    }
    if (code3 === 91) {
      effects.consume(code3);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      marker = 4;
      return self.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return self.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function cdataOpenInside(code3) {
    const value = "CDATA[";
    if (code3 === value.charCodeAt(index2++)) {
      effects.consume(code3);
      if (index2 === value.length) {
        return self.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function tagName(code3) {
    if (code3 === null || code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      const slash = code3 === 47;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        return self.interrupt ? ok3(code3) : continuation(code3);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code3);
          return basicSelfClosing;
        }
        return self.interrupt ? ok3(code3) : continuation(code3);
      }
      marker = 7;
      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code3) : closingTag ? completeClosingTagAfter(code3) : completeAttributeNameBefore(code3);
    }
    if (code3 === 45 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function basicSelfClosing(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      return self.interrupt ? ok3 : continuation;
    }
    return nok(code3);
  }
  function completeClosingTagAfter(code3) {
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeClosingTagAfter;
    }
    return completeEnd(code3);
  }
  function completeAttributeNameBefore(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      return completeEnd;
    }
    if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameBefore;
    }
    return completeEnd(code3);
  }
  function completeAttributeName(code3) {
    if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code3);
  }
  function completeAttributeNameAfter(code3) {
    if (code3 === 61) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code3);
  }
  function completeAttributeValueBefore(code3) {
    if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
      return nok(code3);
    }
    if (code3 === 34 || code3 === 39) {
      effects.consume(code3);
      markerB = code3;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code3);
  }
  function completeAttributeValueQuoted(code3) {
    if (code3 === markerB) {
      effects.consume(code3);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code3 === null || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code3) {
    if (code3 === null || code3 === 34 || code3 === 39 || code3 === 47 || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96 || markdownLineEndingOrSpace(code3)) {
      return completeAttributeNameAfter(code3);
    }
    effects.consume(code3);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code3) {
    if (code3 === 47 || code3 === 62 || markdownSpace(code3)) {
      return completeAttributeNameBefore(code3);
    }
    return nok(code3);
  }
  function completeEnd(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function completeAfter(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return continuation(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function continuation(code3) {
    if (code3 === 45 && marker === 2) {
      effects.consume(code3);
      return continuationCommentInside;
    }
    if (code3 === 60 && marker === 1) {
      effects.consume(code3);
      return continuationRawTagOpen;
    }
    if (code3 === 62 && marker === 4) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === 63 && marker === 3) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    if (code3 === 93 && marker === 5) {
      effects.consume(code3);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code3) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("htmlFlowData");
      return continuationStart(code3);
    }
    effects.consume(code3);
    return continuation;
  }
  function continuationStart(code3) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code3);
  }
  function continuationStartNonLazy(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return continuationStart(code3);
    }
    effects.enter("htmlFlowData");
    return continuation(code3);
  }
  function continuationCommentInside(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationRawTagOpen(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationRawEndTag(code3) {
    if (code3 === 62) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code3);
        return continuationClose;
      }
      return continuation(code3);
    }
    if (asciiAlpha(code3) && buffer.length < 8) {
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationCdataInside(code3) {
    if (code3 === 93) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationDeclarationInside(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === 45 && marker === 2) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationClose(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code3);
    }
    effects.consume(code3);
    return continuationClose;
  }
  function continuationAfter(code3) {
    effects.exit("htmlFlow");
    return ok3(code3);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return self.parser.lazy[self.now().line] ? nok(code3) : ok3(code3);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start;
  function start(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok3, nok) {
  const self = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code3) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === 33) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === 47) {
      effects.consume(code3);
      return tagCloseStart;
    }
    if (code3 === 63) {
      effects.consume(code3);
      return instruction;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return commentOpenInside;
    }
    if (code3 === 91) {
      effects.consume(code3);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return declaration;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return commentEnd;
    }
    return nok(code3);
  }
  function comment(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 45) {
      effects.consume(code3);
      return commentClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = comment;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return comment;
  }
  function commentClose(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return commentEnd;
    }
    return comment(code3);
  }
  function commentEnd(code3) {
    return code3 === 62 ? end(code3) : code3 === 45 ? commentClose(code3) : comment(code3);
  }
  function cdataOpenInside(code3) {
    const value = "CDATA[";
    if (code3 === value.charCodeAt(index2++)) {
      effects.consume(code3);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code3);
  }
  function cdata(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.consume(code3);
      return cdataClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = cdata;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return cdata;
  }
  function cdataClose(code3) {
    if (code3 === 93) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function cdataEnd(code3) {
    if (code3 === 62) {
      return end(code3);
    }
    if (code3 === 93) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function declaration(code3) {
    if (code3 === null || code3 === 62) {
      return end(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = declaration;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return declaration;
  }
  function instruction(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 63) {
      effects.consume(code3);
      return instructionClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = instruction;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return instruction;
  }
  function instructionClose(code3) {
    return code3 === 62 ? end(code3) : instruction(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return nok(code3);
  }
  function tagClose(code3) {
    if (code3 === 45 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return tagCloseBetween(code3);
  }
  function tagCloseBetween(code3) {
    if (markdownLineEnding(code3)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagCloseBetween;
    }
    return end(code3);
  }
  function tagOpen(code3) {
    if (code3 === 45 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function tagOpenBetween(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      return end;
    }
    if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenBetween;
    }
    return end(code3);
  }
  function tagOpenAttributeName(code3) {
    if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code3);
  }
  function tagOpenAttributeNameAfter(code3) {
    if (code3 === 61) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code3);
  }
  function tagOpenAttributeValueBefore(code3) {
    if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
      return nok(code3);
    }
    if (code3 === 34 || code3 === 39) {
      effects.consume(code3);
      marker = code3;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code3 === null) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code3) {
    if (code3 === null || code3 === 34 || code3 === 39 || code3 === 60 || code3 === 61 || code3 === 96) {
      return nok(code3);
    }
    if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code3) {
    if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function end(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok3;
    }
    return nok(code3);
  }
  function lineEndingBefore(code3) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code3) {
    return markdownSpace(code3) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code3) : lineEndingAfterPrefix(code3);
  }
  function lineEndingAfterPrefix(code3) {
    effects.enter("htmlTextData");
    return returnState(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
var referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  while (++index2 < events.length) {
    const token = events[index2][1];
    newEvents.push(events[index2]);
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      const offset = token.type === "labelImage" ? 4 : 2;
      token.type = "data";
      index2 += offset;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: {
      ...events[open][1].start
    },
    end: {
      ...events[events.length - 1][1].end
    }
  };
  const label = {
    type: "label",
    start: {
      ...events[open][1].start
    },
    end: {
      ...events[close][1].end
    }
  };
  const text5 = {
    type: "labelText",
    start: {
      ...events[open + offset + 2][1].end
    },
    end: {
      ...events[close - 2][1].start
    }
  };
  media = [["enter", group, context], ["enter", label, context]];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text5, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
  media = push(media, [["exit", text5, context], events[close - 2], events[close - 1], ["exit", label, context]]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self = this;
  let index2 = self.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self.events[index2][1].type === "labelImage" || self.events[index2][1].type === "labelLink") && !self.events[index2][1]._balanced) {
      labelStart = self.events[index2][1];
      break;
    }
  }
  return start;
  function start(code3) {
    if (!labelStart) {
      return nok(code3);
    }
    if (labelStart._inactive) {
      return labelEndNok(code3);
    }
    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code3);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code3) {
    if (code3 === 40) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code3);
    }
    if (code3 === 91) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code3);
    }
    return defined ? labelEndOk(code3) : labelEndNok(code3);
  }
  function referenceNotFull(code3) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code3);
  }
  function labelEndOk(code3) {
    return ok3(code3);
  }
  function labelEndNok(code3) {
    labelStart._balanced = true;
    return nok(code3);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code3) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code3);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceOpen)(code3) : resourceOpen(code3);
  }
  function resourceOpen(code3) {
    if (code3 === 41) {
      return resourceEnd(code3);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code3);
  }
  function resourceDestinationAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceBetween)(code3) : resourceEnd(code3);
  }
  function resourceDestinationMissing(code3) {
    return nok(code3);
  }
  function resourceBetween(code3) {
    if (code3 === 34 || code3 === 39 || code3 === 40) {
      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code3);
    }
    return resourceEnd(code3);
  }
  function resourceTitleAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceEnd)(code3) : resourceEnd(code3);
  }
  function resourceEnd(code3) {
    if (code3 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code3);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok3;
    }
    return nok(code3);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self = this;
  return referenceFull;
  function referenceFull(code3) {
    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code3);
  }
  function referenceFullAfter(code3) {
    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok3(code3) : nok(code3);
  }
  function referenceFullMissing(code3) {
    return nok(code3);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code3) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code3);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code3) {
    if (code3 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code3);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code3) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code3);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code3) {
    if (code3 === 91) {
      effects.enter("labelMarker");
      effects.consume(code3);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return code3 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code3) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code3);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code3) {
    return code3 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok3) {
  return start;
  function start(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return factorySpace(effects, ok3, "linePrefix");
  }
}

// node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code3) {
    effects.enter("thematicBreak");
    return before(code3);
  }
  function before(code3) {
    marker = code3;
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code3);
    }
    if (size >= 3 && (code3 === null || markdownLineEnding(code3))) {
      effects.exit("thematicBreak");
      return ok3(code3);
    }
    return nok(code3);
  }
  function sequence(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code3) ? factorySpace(effects, atBreak, "whitespace")(code3) : atBreak(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/list.js
var list = {
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = {
  partial: true,
  tokenize: tokenizeIndent
};
function tokenizeListStart(effects, ok3, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code3) {
    const kind = self.containerState.type || (code3 === 42 || code3 === 43 || code3 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self.containerState.marker || code3 === self.containerState.marker : asciiDigit(code3)) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code3 === 42 || code3 === 45 ? effects.check(thematicBreak, nok, atMarker)(code3) : atMarker(code3);
      }
      if (!self.interrupt || code3 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code3);
      }
    }
    return nok(code3);
  }
  function inside(code3) {
    if (asciiDigit(code3) && ++size < 10) {
      effects.consume(code3);
      return inside;
    }
    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code3 === self.containerState.marker : code3 === 41 || code3 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code3);
    }
    return nok(code3);
  }
  function atMarker(code3) {
    effects.enter("listItemMarker");
    effects.consume(code3);
    effects.exit("listItemMarker");
    self.containerState.marker = self.containerState.marker || code3;
    return effects.check(
      blankLine,
      // Canâ€™t be empty when interrupting.
      self.interrupt ? nok : onBlank,
      effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
    );
  }
  function onBlank(code3) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code3);
  }
  function otherPrefix(code3) {
    if (markdownSpace(code3)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code3);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code3);
  }
  function endOfPrefix(code3) {
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok3(code3);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self = this;
  self.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code3) {
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    return factorySpace(effects, ok3, "listItemIndent", self.containerState.size + 1)(code3);
  }
  function notBlank(code3) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code3)) {
      self.containerState.furtherBlankLines = void 0;
      self.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code3);
    }
    self.containerState.furtherBlankLines = void 0;
    self.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code3);
  }
  function notInCurrentItem(code3) {
    self.containerState._closeFlow = true;
    self.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok3, nok), "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code3);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self.containerState.size + 1);
  function afterPrefix(code3) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok3(code3) : nok(code3);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code3) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code3) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text5;
  let definition3;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text5 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition3 && events[index2][1].type === "definition") {
        definition3 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: {
      ...events[content3][1].start
    },
    end: {
      ...events[events.length - 1][1].end
    }
  };
  events[text5][1].type = "setextHeadingText";
  if (definition3) {
    events.splice(text5, 0, ["enter", heading2, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = {
      ...events[definition3][1].end
    };
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self = this;
  let marker;
  return start;
  function start(code3) {
    let index2 = self.events.length;
    let paragraph2;
    while (index2--) {
      if (self.events[index2][1].type !== "lineEnding" && self.events[index2][1].type !== "linePrefix" && self.events[index2][1].type !== "content") {
        paragraph2 = self.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code3;
      return before(code3);
    }
    return nok(code3);
  }
  function before(code3) {
    effects.enter("setextHeadingLineSequence");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code3) ? factorySpace(effects, after, "lineSuffix")(code3) : after(code3);
  }
  function after(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("setextHeadingLine");
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix"))
  );
  return initial;
  function atBlankEnding(code3) {
    if (code3 === null) {
      effects.consume(code3);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code3);
    effects.exit("lineEndingBlank");
    self.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code3) {
    if (code3 === null) {
      effects.consume(code3);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    self.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self = this;
    const constructs2 = this.parser.constructs[field];
    const text5 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code3) {
      return atBreak(code3) ? text5(code3) : notText(code3);
    }
    function notText(code3) {
      if (code3 === null) {
        effects.consume(code3);
        return;
      }
      effects.enter("data");
      effects.consume(code3);
      return data;
    }
    function data(code3) {
      if (atBreak(code3)) {
        effects.exit("data");
        return text5(code3);
      }
      effects.consume(code3);
      return data;
    }
    function atBreak(code3) {
      if (code3 === null) {
        return true;
      }
      const list4 = constructs2[code3];
      let index2 = -1;
      if (list4) {
        while (++index2 < list4.length) {
          const item = list4[index2];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size = 0;
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size
          },
          end: {
            ...data.end
          }
        };
        data.end = {
          ...token.start
        };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point3 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit3,
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    code: null,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: null,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const {
      _bufferIndex,
      _index,
      line,
      column,
      offset
    } = point3;
    return {
      _bufferIndex,
      _index,
      line,
      column,
      offset
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point3._index < chunks.length) {
      const chunk = chunks[point3._index];
      if (typeof chunk === "string") {
        chunkIndex = point3._index;
        if (point3._bufferIndex < 0) {
          point3._bufferIndex = 0;
        }
        while (point3._index === chunkIndex && point3._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point3._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code3) {
    consumed = void 0;
    expectedCode = code3;
    state = state(code3);
  }
  function consume(code3) {
    if (markdownLineEnding(code3)) {
      point3.line++;
      point3.column = 1;
      point3.offset += code3 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code3 !== -1) {
      point3.column++;
      point3.offset++;
    }
    if (point3._bufferIndex < 0) {
      point3._index++;
    } else {
      point3._bufferIndex++;
      if (point3._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point3._index].length) {
        point3._bufferIndex = -1;
        point3._index++;
      }
    }
    context.previous = code3;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map4) {
        return start;
        function start(code3) {
          const left = code3 !== null && map4[code3];
          const all2 = code3 !== null && map4.null;
          const list4 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list4)(code3);
        }
      }
      function handleListOfConstructs(list4) {
        listOfConstructs = list4;
        constructIndex = 0;
        if (list4.length === 0) {
          return bogusState;
        }
        return handleConstruct(list4[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code3) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code3);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a â€œlive bindingâ€, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code3);
        }
      }
      function ok3(code3) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code3) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      from: startEventsIndex,
      restore
    };
    function restore() {
      point3 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point3.line in columnStart && point3.column < 2) {
      point3.column = columnStart[point3.line];
      point3.offset += columnStart[point3.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create(content),
    defined: [],
    document: create(document2),
    flow: create(flow),
    lazy: {},
    string: create(string),
    text: create(text)
  };
  return parser;
  function create(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code3;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code3 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code3 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code3) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/mdast-util-from-markdown/lib/index.js
var own2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list4, onenterlistordered),
      listUnordered: opener(list4),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit3,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace": {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: weâ€™ll add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create, and) {
    return open;
    function open(token) {
      enter.call(this, create(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || void 0]);
    node2.position = {
      start: point2(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node2.position.end = point2(token.end);
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text5();
      tail.position = {
        start: point2(token.start),
        // @ts-expect-error: weâ€™ll add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list4(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text5() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak3() {
    return {
      type: "thematicBreak"
    };
  }
}
function point2(d) {
  return {
    line: d.line,
    column: d.column,
    offset: d.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self = this;
  self.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self.data("micromarkExtensions") || [],
      mdastExtensions: self.data("fromMarkdownExtensions") || []
    });
  }
}

// node_modules/ccount/index.js
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        propertiesFactory(
          /** @type {Props} */
          test
        )
      );
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propertiesFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty : [value];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list4, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list4);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings = parent.children;
    const index2 = siblings.indexOf(node2);
    let change = false;
    let nodes = [];
    find.lastIndex = 0;
    let match = find.exec(node2.value);
    while (match) {
      const position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find.lastIndex = position2 + 1;
      } else {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find.global) {
        break;
      }
      match = find.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list4 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list4.length) {
    const tuple = list4[index2];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find) {
  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_, protocol, domain2, path2, match) {
  let prefix = "";
  if (!previous2(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous2(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous2(match, email) {
  const code3 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code3) || unicodePunctuation(code3)) && // If itâ€™s an email, the previous character should not be a slash.
  (!email || code3 !== 47);
}

// node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
  this.buffer();
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteReference");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteDefinition");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteReference(node2, _, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit3 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), { after: "]", before: value })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition
    }
  };
}
function gfmFootnoteToMarkdown(options) {
  let firstLineBlank = false;
  if (options && options.firstLineBlank) {
    firstLineBlank = true;
  }
  return {
    handlers: { footnoteDefinition, footnoteReference },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function footnoteDefinition(node2, _, state, info) {
    const tracker = state.createTracker(info);
    let value = tracker.move("[^");
    const exit3 = state.enter("footnoteDefinition");
    const subexit = state.enter("label");
    value += tracker.move(
      state.safe(state.associationId(node2), { before: value, after: "]" })
    );
    subexit();
    value += tracker.move("]:");
    if (node2.children && node2.children.length > 0) {
      tracker.shift(4);
      value += tracker.move(
        (firstLineBlank ? "\n" : " ") + state.indentLines(
          state.containerFlow(node2, tracker.current()),
          firstLineBlank ? mapAll : mapExceptFirst
        )
      );
    }
    exit3();
    return value;
  }
}
function mapExceptFirst(line, index2, blank) {
  return index2 === 0 ? line : mapAll(line, index2, blank);
}
function mapAll(line, index2, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _, state, info) {
  const tracker = state.createTracker(info);
  const exit3 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// node_modules/markdown-table/index.js
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table[rowIndex].length;
    }
    while (++columnIndex2 < table[rowIndex].length) {
      const cell = serialize(table[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code3 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code3;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code3 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code3 === 99) {
      before = ":";
      after = ":";
    } else if (code3 === 108) {
      before = ":";
    } else if (code3 === 114) {
      after = ":";
    }
    let size = settings.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (settings.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code3 = alignments[columnIndex];
        if (code3 === 114) {
          before = " ".repeat(size);
        } else if (code3 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings.padding !== false && // Donâ€™t add the opening space if weâ€™re not aligning and the cell is
      // empty: there will be a closing space.
      !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (settings.alignDelimiters !== false) {
        line.push(after);
      }
      if (settings.padding !== false) {
        line.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
  const code3 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code3 === 67 || code3 === 99 ? 99 : code3 === 76 || code3 === 108 ? 108 : code3 === 82 || code3 === 114 ? 114 : 0;
}

// node_modules/zwitch/index.js
var own3 = {}.hasOwnProperty;
function zwitch(key, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value && own3.call(value, key)) {
      const id = String(value[key]);
      fn = own3.call(handlers, id) ? handlers[id] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}

// node_modules/mdast-util-to-markdown/lib/configure.js
var own4 = {}.hasOwnProperty;
function configure2(base, extension2) {
  let index2 = -1;
  let key;
  if (extension2.extensions) {
    while (++index2 < extension2.extensions.length) {
      configure2(base, extension2.extensions[index2]);
    }
  }
  for (key in extension2) {
    if (own4.call(extension2, key)) {
      switch (key) {
        case "extensions": {
          break;
        }
        case "unsafe": {
          list2(base[key], extension2[key]);
          break;
        }
        case "join": {
          list2(base[key], extension2[key]);
          break;
        }
        case "handlers": {
          map(base[key], extension2[key]);
          break;
        }
        default: {
          base.options[key] = extension2[key];
        }
      }
    }
  }
  return base;
}
function list2(left, right) {
  if (right) {
    left.push(...right);
  }
}
function map(left, right) {
  if (right) {
    Object.assign(left, right);
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node2, _, state, info) {
  const exit3 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map2
  );
  exit3();
  return value;
}
function map2(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list4, none) {
  if (typeof list4 === "string") {
    list4 = [list4];
  }
  if (!list4 || list4.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list4.length) {
    if (stack.includes(list4[index2])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source = String(value);
  let index2 = source.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source.indexOf(substring, expected);
  }
  return max;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If thereâ€™s no infoâ€¦
    !node2.lang && // And thereâ€™s a non-whitespace characterâ€¦
    /[^ \r\n]/.test(node2.value) && // And the value doesnâ€™t start or end in a blankâ€¦
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node2, _, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit4 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map3);
    exit4();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit3 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit3();
  return value;
}
function map3(line, _, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition2(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If thereâ€™s no url, orâ€¦
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
function encodeCharacterReference(code3) {
  return "&#x" + code3.toString(16).toUpperCase() + ";";
}

// node_modules/mdast-util-to-markdown/lib/util/encode-info.js
function encodeInfo(outside, inside, marker) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === void 0) {
    return insideKind === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: false, outside: true }
    );
  }
  if (outsideKind === 1) {
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  return insideKind === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : insideKind === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node2, _, state, info) {
  const marker = checkEmphasis(state);
  const exit3 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between2 + after;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node2, _, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit4 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit4();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole sizeâ€¦
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)â€¦
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit3 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html.peek = htmlPeek;
function html(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If thereâ€™s no url but there is a titleâ€¦
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw = toString(node2);
  return Boolean(
    !state.options.resourceLink && // If thereâ€™s a urlâ€¦
    node2.url && // And thereâ€™s a no titleâ€¦
    !node2.title && // And the content of `node` is a single text nodeâ€¦
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the contentâ€¦
    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocolâ€¦
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnâ€™t contain ASCII control codes (character escapes and
    // references donâ€™t work), space, or angle bracketsâ€¦
    !/[\0- <>\u007F]/.test(node2.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit3 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state.stack = stack;
    return value2;
  }
  exit3 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If thereâ€™s no url but there is a titleâ€¦
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node2, _, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text5 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text5 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !text5 || text5 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list3(node2, parent, state, info) {
  const exit3 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "one";
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit3 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map4
  );
  exit3();
  return value;
  function map4(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node2, _, state, info) {
  const exit3 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node2, _, state, info) {
  const hasPhrasing = node2.children.some(function(d) {
    return phrasing(d);
  });
  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return container.call(state, node2, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node2, _, state, info) {
  const marker = checkStrong(state);
  const exit3 = state.enter("strong");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker + marker);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker + marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between2 + after;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text3(node2, _, state, info) {
  return state.safe(node2.value, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak2(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code,
  definition: definition2,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list: list3,
  listItem,
  paragraph,
  root,
  strong,
  text: text3,
  thematicBreak: thematicBreak2
};

// node_modules/mdast-util-to-markdown/lib/join.js
var join2 = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];

// node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}

// node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js
function compilePattern(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = info.before;
  let encodeAfter;
  indexStack.push(-1);
  let tracker = state.createTracker(info);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle2 = state.handle.handlers[children[index2 + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children[index2 + 1], parent, state, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = state.createTracker(info);
      tracker.move(results.join(""));
    }
    let value = state.handle(child, parent, state, {
      ...tracker.current(),
      after,
      before
    });
    if (encodeAfter && encodeAfter === value.slice(0, 1)) {
      value = encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1);
    }
    const encodingInfo = state.attentionEncodeSurroundingInfo;
    state.attentionEncodeSurroundingInfo = void 0;
    encodeAfter = void 0;
    if (encodingInfo) {
      if (results.length > 0 && encodingInfo.before && before === results[results.length - 1].slice(-1)) {
        results[results.length - 1] = results[results.length - 1].slice(0, -1) + encodeCharacterReference(before.charCodeAt(0));
      }
      if (encodingInfo.after)
        encodeAfter = after;
    }
    tracker.move(value);
    results.push(value);
    before = value.slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info);
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index2 + 1], parent, state))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index2 = state.join.length;
  while (index2--) {
    const result = state.join[index2](left, right, parent, state);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}

// node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value, map4) {
  const result = [];
  let start = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value)) {
    one2(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }
  one2(value.slice(start));
  return result.join("");
  function one2(value2) {
    result.push(map4(value2, line, !value2));
  }
}

// node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(state, input, config) {
  const value = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = state.compilePattern(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position2 = positions[index2];
    if (position2 < start || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start !== position2) {
      result.push(escapeBackslashes(value.slice(start, position2), "\\"));
    }
    start = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config.encode || !config.encode.includes(value.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push(encodeCharacterReference(value.charCodeAt(position2)));
      start++;
    }
  }
  result.push(escapeBackslashes(value.slice(start, end), config.after));
  return result.join("");
}
function numerical(a, b) {
  return a - b;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index2 = -1;
  let start = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index2 < positions.length) {
    if (start !== positions[index2]) {
      results.push(value.slice(start, positions[index2]));
    }
    results.push("\\");
    start = positions[index2];
  }
  results.push(value.slice(start));
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(config) {
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value) {
    lineShift += value;
  }
  function move(input) {
    const value = input || "";
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}

// node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options) {
  const settings = options || {};
  const state = {
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    compilePattern,
    enter,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...handle },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines,
    indexStack: [],
    join: [...join2],
    options: {},
    safe: safeBound,
    stack: [],
    unsafe: [...unsafe]
  };
  configure2(state, settings);
  if (state.options.tightDefinitions) {
    state.join.push(joinDefinition);
  }
  state.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state.handlers
  });
  let result = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name) {
    state.stack.push(name);
    return exit3;
    function exit3() {
      state.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(value) {
  const node2 = (
    /** @type {Nodes} */
    value
  );
  throw new Error("Cannot handle unknown node `" + node2.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow(parent, this, info);
}
function safeBound(value, config) {
  return safe(this, value, config);
}

// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit2,
      tableHeader: exit2,
      tableRow: exit2
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d) {
        return d === "none" ? null : d;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _, state, info) {
    const row = handleTableRowAsData(node2, state, info);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _, state, info) {
    const exit3 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(children[index2], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(children[index2], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "paragraph");
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(options),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}

// node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
var wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
var domain = {
  tokenize: tokenizeDomain,
  partial: true
};
var path = {
  tokenize: tokenizePath,
  partial: true
};
var trail = {
  tokenize: tokenizeTrail,
  partial: true
};
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text4 = {};
function gfmAutolinkLiteral() {
  return {
    text: text4
  };
}
var code2 = 48;
while (code2 < 123) {
  text4[code2] = emailAutolink;
  code2++;
  if (code2 === 58)
    code2 = 65;
  else if (code2 === 91)
    code2 = 97;
}
text4[43] = emailAutolink;
text4[45] = emailAutolink;
text4[46] = emailAutolink;
text4[95] = emailAutolink;
text4[72] = [emailAutolink, protocolAutolink];
text4[104] = [emailAutolink, protocolAutolink];
text4[87] = [emailAutolink, wwwAutolink];
text4[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self = this;
  let dot;
  let data;
  return start;
  function start(code3) {
    if (!gfmAtext(code3) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code3);
  }
  function atext(code3) {
    if (gfmAtext(code3)) {
      effects.consume(code3);
      return atext;
    }
    if (code3 === 64) {
      effects.consume(code3);
      return emailDomain;
    }
    return nok(code3);
  }
  function emailDomain(code3) {
    if (code3 === 46) {
      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code3);
    }
    if (code3 === 45 || code3 === 95 || asciiAlphanumeric(code3)) {
      data = true;
      effects.consume(code3);
      return emailDomain;
    }
    return emailDomainAfter(code3);
  }
  function emailDomainDot(code3) {
    effects.consume(code3);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code3) {
    if (data && dot && asciiAlpha(self.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self = this;
  return wwwStart;
  function wwwStart(code3) {
    if (code3 !== 87 && code3 !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code3);
  }
  function wwwAfter(code3) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code3);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code3) {
    if ((code3 === 72 || code3 === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    return nok(code3);
  }
  function protocolPrefixInside(code3) {
    if (asciiAlpha(code3) && buffer.length < 5) {
      buffer += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    if (code3 === 58) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code3);
        return protocolSlashesInside;
      }
    }
    return nok(code3);
  }
  function protocolSlashesInside(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code3);
  }
  function afterProtocol(code3) {
    return code3 === null || asciiControl(code3) || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || unicodePunctuation(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code3);
  }
  function protocolAfter(code3) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code3);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code3) {
    if ((code3 === 87 || code3 === 119) && size < 3) {
      size++;
      effects.consume(code3);
      return wwwPrefixInside;
    }
    if (code3 === 46 && size === 3) {
      effects.consume(code3);
      return wwwPrefixAfter;
    }
    return nok(code3);
  }
  function wwwPrefixAfter(code3) {
    return code3 === null ? nok(code3) : ok3(code3);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code3) {
    if (code3 === 46 || code3 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code3);
    }
    if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== 45 && unicodePunctuation(code3)) {
      return domainAfter(code3);
    }
    seen = true;
    effects.consume(code3);
    return domainInside;
  }
  function domainAtPunctuation(code3) {
    if (code3 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code3);
    return domainInside;
  }
  function domainAfter(code3) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code3);
    }
    return ok3(code3);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code3) {
    if (code3 === 40) {
      sizeOpen++;
      effects.consume(code3);
      return pathInside;
    }
    if (code3 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code3);
    }
    if (code3 === 33 || code3 === 34 || code3 === 38 || code3 === 39 || code3 === 41 || code3 === 42 || code3 === 44 || code3 === 46 || code3 === 58 || code3 === 59 || code3 === 60 || code3 === 63 || code3 === 93 || code3 === 95 || code3 === 126) {
      return effects.check(trail, ok3, pathAtPunctuation)(code3);
    }
    if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok3(code3);
    }
    effects.consume(code3);
    return pathInside;
  }
  function pathAtPunctuation(code3) {
    if (code3 === 41) {
      sizeClose++;
    }
    effects.consume(code3);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code3) {
    if (code3 === 33 || code3 === 34 || code3 === 39 || code3 === 41 || code3 === 42 || code3 === 44 || code3 === 46 || code3 === 58 || code3 === 59 || code3 === 63 || code3 === 95 || code3 === 126) {
      effects.consume(code3);
      return trail2;
    }
    if (code3 === 38) {
      effects.consume(code3);
      return trailCharacterReferenceStart;
    }
    if (code3 === 93) {
      effects.consume(code3);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code3 === 60 || // So is whitespace.
      code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)
    ) {
      return ok3(code3);
    }
    return nok(code3);
  }
  function trailBracketAfter(code3) {
    if (code3 === null || code3 === 40 || code3 === 91 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok3(code3);
    }
    return trail2(code3);
  }
  function trailCharacterReferenceStart(code3) {
    return asciiAlpha(code3) ? trailCharacterReferenceInside(code3) : nok(code3);
  }
  function trailCharacterReferenceInside(code3) {
    if (code3 === 59) {
      effects.consume(code3);
      return trail2;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return trailCharacterReferenceInside;
    }
    return nok(code3);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start;
  function start(code3) {
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    return asciiAlphanumeric(code3) ? nok(code3) : ok3(code3);
  }
}
function previousWww(code3) {
  return code3 === null || code3 === 40 || code3 === 42 || code3 === 95 || code3 === 91 || code3 === 93 || code3 === 126 || markdownLineEndingOrSpace(code3);
}
function previousProtocol(code3) {
  return !asciiAlpha(code3);
}
function previousEmail(code3) {
  return !(code3 === 47 || gfmAtext(code3));
}
function gfmAtext(code3) {
  return code3 === 43 || code3 === 45 || code3 === 46 || code3 === 95 || asciiAlphanumeric(code3);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/micromark-extension-gfm-footnote/lib/syntax.js
var indent = {
  tokenize: tokenizeIndent2,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
  const self = this;
  let index2 = self.events.length;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code3) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code3);
    }
    const id = normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    }));
    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code3);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok3(code3);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    // The `[`
    events[index2 + 3],
    events[index2 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok3, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code3) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code3) {
    if (code3 !== 94)
      return nok(code3);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code3) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code3 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code3 === null || code3 === 91 || markdownLineEndingOrSpace(code3)
    ) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {
        return nok(code3);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok3;
    }
    if (!markdownLineEndingOrSpace(code3)) {
      data = true;
    }
    size++;
    effects.consume(code3);
    return code3 === 92 ? callEscape : callData;
  }
  function callEscape(code3) {
    if (code3 === 91 || code3 === 92 || code3 === 93) {
      effects.consume(code3);
      size++;
      return callData;
    }
    return callData(code3);
  }
}
function tokenizeDefinitionStart(effects, ok3, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data;
  return start;
  function start(code3) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code3) {
    if (code3 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code3);
  }
  function labelInside(code3) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code3 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code3 === null || code3 === 91 || markdownLineEndingOrSpace(code3)
    ) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code3)) {
      data = true;
    }
    size++;
    effects.consume(code3);
    return code3 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === 91 || code3 === 92 || code3 === 93) {
      effects.consume(code3);
      size++;
      return labelInside;
    }
    return labelInside(code3);
  }
  function labelAfter(code3) {
    if (code3 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code3);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code3);
  }
  function whitespaceAfter(code3) {
    return ok3(code3);
  }
}
function tokenizeDefinitionContinuation(effects, ok3, nok) {
  return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok3, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code3) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text5 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [["enter", strikethrough, context], ["enter", events[open][1], context], ["exit", events[open][1], context], ["enter", text5, context]];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open + 1, index2), context));
            }
            splice(nextEvents, nextEvents.length, 0, [["exit", text5, context], ["enter", events[index2][1], context], ["exit", events[index2][1], context], ["exit", strikethrough, context]]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code3) {
      if (previous3 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code3);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code3);
    }
    function more(code3) {
      const before = classifyCharacter(previous3);
      if (code3 === 126) {
        if (size > 1)
          return nok(code3);
        effects.consume(code3);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code3);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code3);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok3(code3);
    }
  }
}

// node_modules/micromark-extension-gfm-table/lib/edit-map.js
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index2, remove, add) {
    addImplementation(this, index2, remove, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a, b) {
      return a[0] - b[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]), this.map[index2][2]);
      events.length = this.map[index2][0];
    }
    vecs.push(events.slice());
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      for (const element2 of slice) {
        events.push(element2);
      }
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImplementation(editMap, at, remove, add) {
  let index2 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at) {
      editMap.map[index2][1] += remove;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at, remove, add]);
}

// node_modules/micromark-extension-gfm-table/lib/infer.js
function gfmTableAlign(events, index2) {
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}

// node_modules/micromark-extension-gfm-table/lib/syntax.js
function gfmTable() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(effects, ok3, nok) {
  const self = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code3) {
    let index2 = self.events.length - 1;
    while (index2 > -1) {
      const type = self.events[index2][1].type;
      if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === "linePrefix")
        index2--;
      else
        break;
    }
    const tail = index2 > -1 ? self.events[index2][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {
      return nok(code3);
    }
    return next(code3);
  }
  function headRowBefore(code3) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code3);
  }
  function headRowStart(code3) {
    if (code3 === 124) {
      return headRowBreak(code3);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code3);
  }
  function headRowBreak(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      if (sizeB > 1) {
        sizeB = 0;
        self.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code3);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, headRowBreak, "whitespace")(code3);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code3 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code3);
  }
  function headRowData(code3) {
    if (code3 === null || code3 === 124 || markdownLineEndingOrSpace(code3)) {
      effects.exit("data");
      return headRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code3) {
    if (code3 === 92 || code3 === 124) {
      effects.consume(code3);
      return headRowData;
    }
    return headRowData(code3);
  }
  function headDelimiterStart(code3) {
    self.interrupt = false;
    if (self.parser.lazy[self.now().line]) {
      return nok(code3);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code3)) {
      return factorySpace(effects, headDelimiterBefore, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code3);
    }
    return headDelimiterBefore(code3);
  }
  function headDelimiterBefore(code3) {
    if (code3 === 45 || code3 === 58) {
      return headDelimiterValueBefore(code3);
    }
    if (code3 === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterCellBefore(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code3);
    }
    return headDelimiterValueBefore(code3);
  }
  function headDelimiterValueBefore(code3) {
    if (code3 === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code3 === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      return headDelimiterCellAfter(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterLeftAlignmentAfter(code3) {
    if (code3 === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterFiller(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return headDelimiterFiller;
    }
    if (code3 === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code3);
  }
  function headDelimiterRightAlignmentAfter(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code3);
    }
    return headDelimiterCellAfter(code3);
  }
  function headDelimiterCellAfter(code3) {
    if (code3 === 124) {
      return headDelimiterBefore(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code3);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterNok(code3) {
    return nok(code3);
  }
  function bodyRowStart(code3) {
    effects.enter("tableRow");
    return bodyRowBreak(code3);
  }
  function bodyRowBreak(code3) {
    if (code3 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("tableRow");
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, bodyRowBreak, "whitespace")(code3);
    }
    effects.enter("data");
    return bodyRowData(code3);
  }
  function bodyRowData(code3) {
    if (code3 === null || code3 === 124 || markdownLineEndingOrSpace(code3)) {
      effects.exit("data");
      return bodyRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code3) {
    if (code3 === 92 || code3 === 124) {
      effects.consume(code3);
      return bodyRowData;
    }
    return bodyRowData(code3);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map4 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map4, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map4.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map4.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map4, context, lastCell, rowKind, void 0, currentCell);
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index2;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map4, context, lastCell, rowKind, void 0, currentCell);
          }
          lastCell = cell;
          cell = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(map4, context, lastCell, rowKind, index2, currentCell);
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map4, context, cell, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map4, context, lastTableEnd, currentTable, currentBody);
  }
  map4.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map4, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map4.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map4.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map4.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = "chunkText";
      start[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a = range[2] + 1;
        const b = range[3] - range[2] - 1;
        map4.add(a, b, []);
      }
    }
    map4.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map4.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map4, context, index2, table, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table.end = Object.assign({}, related);
  exits.push(["exit", table, context]);
  map4.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
var tasklistCheck = {
  name: "tasklistCheck",
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      [91]: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self = this;
  return open;
  function open(code3) {
    if (
      // Exit if thereâ€™s stuff before.
      self.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code3);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code3);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code3) {
    if (markdownLineEndingOrSpace(code3)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code3 === 88 || code3 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code3);
  }
  function close(code3) {
    if (code3 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code3);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return effects.check({
        tokenize: spaceThenNonSpace
      }, ok3, nok)(code3);
    }
    return nok(code3);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code3) {
    return code3 === null ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}

// node_modules/remark-gfm/lib/index.js
var emptyOptions2 = {};
function remarkGfm(options) {
  const self = (
    /** @type {Processor<Root>} */
    this
  );
  const settings = options || emptyOptions2;
  const data = self.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}

// node_modules/remark-stringify/lib/index.js
function remarkStringify(options) {
  const self = this;
  self.compiler = compiler2;
  function compiler2(tree) {
    return toMarkdown(tree, {
      ...self.data("settings"),
      ...options,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self.data("toMarkdownExtensions") || []
    });
  }
}

// src/utils/Logger.ts
var Logger = class {
  static setDebugMode(enabled) {
    this.debugMode = enabled;
    if (enabled) {
      console.log(this.prefix, "Debug mode enabled");
    }
  }
  static log(...args) {
    if (this.debugMode) {
      console.log(this.prefix, ...args);
    }
  }
  static warn(...args) {
    if (this.debugMode) {
      console.warn(this.prefix, ...args);
    }
  }
  static error(...args) {
    console.error(this.prefix, ...args);
  }
};
Logger.debugMode = false;
Logger.prefix = "[WDTTG]";

// src/data/TableParser.ts
var TableParser = class {
  /** Create the unified processor for parsing */
  static createParser() {
    return unified().use(remarkParse).use(remarkGfm);
  }
  /** Create the unified processor for serializing */
  static createSerializer() {
    return unified().use(remarkParse).use(remarkGfm).use(remarkStringify, {
      bullet: "-",
      fence: "`",
      fences: true,
      incrementListMarker: false
    });
  }
  /**
   * Parse a monthly file content into entries
   */
  static parseMonthFile(content3, monthStr) {
    const entries = [];
    const entriesByDate = /* @__PURE__ */ new Map();
    const processor = this.createParser();
    const tree = processor.parse(content3);
    for (const node2 of tree.children) {
      if (node2.type === "table") {
        const tableEntries = this.parseTable(node2);
        for (const entry of tableEntries) {
          entries.push(entry);
          if (!entriesByDate.has(entry.date)) {
            entriesByDate.set(entry.date, []);
          }
          entriesByDate.get(entry.date).push(entry);
        }
      }
    }
    return {
      month: monthStr,
      entries,
      entriesByDate
    };
  }
  /**
   * Parse a table node into TimeEntry array
   */
  static parseTable(table) {
    const entries = [];
    const rows = table.children;
    if (rows.length < 2) {
      return entries;
    }
    const headerRow = rows[0];
    const headerMap = this.getHeaderMap(headerRow);
    for (let i = 1; i < rows.length; i++) {
      const row = rows[i];
      const entry = this.parseRow(row, headerMap, i);
      if (entry) {
        entries.push(entry);
      }
    }
    return entries;
  }
  /**
   * Build a map of header name -> column index
   */
  static getHeaderMap(headerRow) {
    const map4 = /* @__PURE__ */ new Map();
    const cells = headerRow.children;
    for (let i = 0; i < cells.length; i++) {
      const text5 = this.getCellText(cells[i]).toLowerCase();
      map4.set(text5, i);
    }
    return map4;
  }
  /**
   * Parse a table row into a TimeEntry
   */
  static parseRow(row, headerMap, rowIndex) {
    const cells = row.children;
    const getValue = (header) => {
      const index2 = headerMap.get(header.toLowerCase());
      if (index2 === void 0 || index2 >= cells.length)
        return "";
      return this.getCellText(cells[index2]);
    };
    const startStr = getValue("start");
    const endStr = getValue("end");
    const client = getValue("client");
    if (!startStr || !endStr || !client) {
      Logger.log("TableParser: Missing required fields (start, end, or client)");
      return null;
    }
    const startDateTime = this.parseDateTime(startStr);
    const endDateTime = this.parseDateTime(endStr);
    if (!startDateTime || !endDateTime) {
      Logger.log("TableParser: Invalid datetime format");
      return null;
    }
    const date = this.getDateString(startDateTime);
    const durationMinutes = Math.round((endDateTime.getTime() - startDateTime.getTime()) / 6e4);
    const start = this.formatTime(startDateTime);
    const end = this.formatTime(endDateTime);
    const notes = getValue("notes");
    let linkedNote;
    if (notes) {
      const wikiMatch = notes.match(/\[\[([^\]]+)\]\]/);
      if (wikiMatch) {
        linkedNote = wikiMatch[1];
      }
    }
    return {
      date,
      start,
      end,
      description: this.parseDescription(getValue("description")),
      client,
      project: getValue("project") || void 0,
      activity: getValue("activity") || void 0,
      linkedNote,
      startDateTime,
      endDateTime,
      lineNumber: rowIndex,
      // Row index in table (not file line number)
      durationMinutes
    };
  }
  /**
   * Get text content from a table cell
   */
  static getCellText(cell) {
    let text5 = "";
    for (const child of cell.children) {
      if (child.type === "text") {
        text5 += child.value;
      } else if (child.type === "inlineCode") {
        text5 += child.value;
      } else if ("children" in child) {
        text5 += this.getNodeText(child);
      }
    }
    return text5.trim();
  }
  /**
   * Recursively get text from any node
   */
  static getNodeText(node2) {
    if (!node2 || typeof node2 !== "object")
      return "";
    const n = node2;
    if (n.type === "text" && typeof n.value === "string") {
      return n.value;
    }
    if (Array.isArray(n.children)) {
      return n.children.map((child) => this.getNodeText(child)).join("");
    }
    return "";
  }
  /**
   * Parse datetime string "YYYY-MM-DD HH:mm" into Date
   */
  static parseDateTime(str) {
    const match = str.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})$/);
    if (!match) {
      return null;
    }
    const [, year, month, day, hours, minutes] = match.map(Number);
    return new Date(year, month - 1, day, hours, minutes);
  }
  /**
   * Format a Date to HH:mm string
   */
  static formatTime(date) {
    return `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}`;
  }
  /**
   * Get the date string (YYYY-MM-DD) for a given date
   */
  static getDateString(date) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  /**
   * Get the month string (YYYY-MM) for a given date
   */
  static getMonthString(date) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    return `${year}-${month}`;
  }
  /**
   * Format a Date to "YYYY-MM-DD HH:mm" string for table cells
   */
  static formatDateTime(date) {
    return `${this.getDateString(date)} ${this.formatTime(date)}`;
  }
  /**
   * Generate markdown table content from entries
   */
  static generateTable(entries) {
    const sorted = [...entries].sort(
      (a, b) => a.startDateTime.getTime() - b.startDateTime.getTime()
    );
    const tableRows = [];
    tableRows.push({
      type: "tableRow",
      children: this.HEADERS.map((h) => ({
        type: "tableCell",
        children: [{ type: "text", value: h }]
      }))
    });
    for (const entry of sorted) {
      tableRows.push({
        type: "tableRow",
        children: [
          this.createCell(this.formatDateTime(entry.startDateTime)),
          this.createCell(this.formatDateTime(entry.endDateTime)),
          this.createCell(this.serializeDescription(entry.description)),
          this.createCell(entry.client),
          this.createCell(entry.project || ""),
          this.createCell(entry.activity || ""),
          this.createCell(entry.linkedNote ? `[[${entry.linkedNote}]]` : "")
        ]
      });
    }
    const table = {
      type: "table",
      align: ["left", "left", "left", "left", "left", "left", "left"],
      children: tableRows
    };
    const root2 = {
      type: "root",
      children: [table]
    };
    const processor = this.createSerializer();
    let result = processor.stringify(root2);
    result = result.replace(/\\\[\\\[/g, "[[").replace(/\\\]\\\]/g, "]]");
    return result;
  }
  /**
   * Create a table cell with text content
   */
  static createCell(text5) {
    return {
      type: "tableCell",
      children: [{ type: "text", value: text5 }]
    };
  }
  /**
   * Convert newlines to <br> for table storage
   */
  static serializeDescription(description) {
    return description.replace(/\n/g, "<br>");
  }
  /**
   * Convert <br> back to newlines for display
   */
  static parseDescription(description) {
    return description.replace(/<br\s*\/?>/gi, "\n");
  }
  /**
   * Generate a complete month file with header and table
   * @param entries - Time entries for the month
   * @param monthStr - Month string (YYYY-MM)
   * @param hideTable - If true, wrap table in %% comments to hide in reading view
   */
  static generateMonthFile(entries, monthStr, hideTable = true) {
    const header = this.getFileHeader();
    const table = this.generateTable(entries);
    if (hideTable) {
      return `${header}
# ${monthStr}

%%
${table}%%
`;
    } else {
      return `${header}
# ${monthStr}

${table}`;
    }
  }
  /**
   * Warning header added to the top of monthly files
   */
  static getFileHeader() {
    return `%%
\u26A0\uFE0F WARNING: This file is managed by the "Where Did The Time Go" plugin.
Do not edit manually - your changes may be overwritten.
Use the Timeline view to create, edit, or delete entries.

FILE STRUCTURE:
- One file per month, named YYYY-MM.md
- Single table containing all entries for the month
- Entries sorted chronologically by start time

TABLE COLUMNS:
| Start | End | Description | Client | Project | Activity | Notes |
- Start (required): Start date and time (YYYY-MM-DD HH:mm)
- End (required): End date and time (may be next day for overnight entries)
- Description: Free text describing the activity
- Client (required): Client for billing
- Project (optional): Project name
- Activity (optional): Work type classification
- Notes (optional): Obsidian wikilink [[linked note]]
%%
`;
  }
};
/** Expected column headers (case-insensitive matching) */
TableParser.HEADERS = ["Start", "End", "Description", "Client", "Project", "Activity", "Notes"];

// src/data/DataManager.ts
var _DataManager = class {
  constructor(vault, settings) {
    this.cache = /* @__PURE__ */ new Map();
    this.vault = vault;
    this.settings = settings;
  }
  /**
   * Update settings reference (called when settings change)
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Clear the cache (called on external file changes)
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Invalidate cache for a specific month
   */
  invalidateMonth(monthStr) {
    this.cache.delete(monthStr);
  }
  /**
   * Ensure the time tracking folder exists
   */
  async ensureFolderExists() {
    const folderPath = this.settings.timeTrackingFolder;
    let folder = this.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      if (this.settings.autoCreateFolder) {
        await this.vault.createFolder(folderPath);
        folder = this.vault.getAbstractFileByPath(folderPath);
      } else {
        throw new Error(`Time tracking folder "${folderPath}" does not exist`);
      }
    }
    if (!(folder instanceof import_obsidian3.TFolder)) {
      throw new Error(`"${folderPath}" is not a folder`);
    }
    return folder;
  }
  /**
   * Get the file path for a monthly file
   */
  getMonthFilePath(monthStr) {
    return `${this.settings.timeTrackingFolder}/${monthStr}.md`;
  }
  /**
   * Get or create the monthly file for a given month
   */
  async getOrCreateMonthFile(monthStr) {
    await this.ensureFolderExists();
    const filePath = this.getMonthFilePath(monthStr);
    let file = this.vault.getAbstractFileByPath(filePath);
    if (!file) {
      const content3 = TableParser.generateMonthFile([], monthStr, this.settings.hideTablesInPreview);
      file = await this.vault.create(filePath, content3);
    }
    if (!(file instanceof import_obsidian3.TFile)) {
      throw new Error(`"${filePath}" is not a file`);
    }
    return file;
  }
  /**
   * Load entries for a specific month
   */
  async loadMonth(monthStr) {
    if (this.cache.has(monthStr)) {
      Logger.log("DataManager: Cache hit for", monthStr);
      return this.cache.get(monthStr);
    }
    const filePath = this.getMonthFilePath(monthStr);
    Logger.log("DataManager: Loading file", filePath);
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian3.TFile)) {
      Logger.log("DataManager: File not found");
      const emptyMonth = {
        month: monthStr,
        entries: [],
        entriesByDate: /* @__PURE__ */ new Map()
      };
      return emptyMonth;
    }
    const content3 = await this.vault.read(file);
    const parsed = TableParser.parseMonthFile(content3, monthStr);
    Logger.log("DataManager: Parsed", parsed.entries.length, "entries");
    this.cache.set(monthStr, parsed);
    if (this.cache.size > _DataManager.MAX_CACHED_MONTHS) {
      const oldestKey = this.cache.keys().next().value;
      if (oldestKey) {
        this.cache.delete(oldestKey);
      }
    }
    return parsed;
  }
  /**
   * Load entries for a date range
   * Returns entries that OVERLAP with the range (not just start within)
   */
  async loadDateRange(startDate, endDate) {
    const entries = [];
    const monthsToLoad = /* @__PURE__ */ new Set();
    const monthBefore = new Date(startDate);
    monthBefore.setMonth(monthBefore.getMonth() - 1);
    monthsToLoad.add(TableParser.getMonthString(monthBefore));
    const endMonth = TableParser.getMonthString(endDate);
    const current = new Date(startDate);
    current.setDate(1);
    while (TableParser.getMonthString(current) <= endMonth) {
      monthsToLoad.add(TableParser.getMonthString(current));
      current.setMonth(current.getMonth() + 1);
    }
    for (const monthStr of monthsToLoad) {
      const parsed = await this.loadMonth(monthStr);
      entries.push(...parsed.entries);
    }
    return entries.filter(
      (e) => e.startDateTime < endDate && e.endDateTime > startDate
    ).sort((a, b) => a.startDateTime.getTime() - b.startDateTime.getTime());
  }
  /**
   * Calculate effective duration of an entry within a date range
   * Handles entries that span midnight by only counting time within the range
   */
  getEffectiveDuration(entry, rangeStart, rangeEnd) {
    const effectiveStart = entry.startDateTime < rangeStart ? rangeStart : entry.startDateTime;
    const effectiveEnd = entry.endDateTime > rangeEnd ? rangeEnd : entry.endDateTime;
    const durationMs = effectiveEnd.getTime() - effectiveStart.getTime();
    return Math.max(0, Math.round(durationMs / 6e4));
  }
  /**
   * Load entries for a specific date
   */
  async loadEntriesForDate(date) {
    const monthStr = TableParser.getMonthString(date);
    const dateStr = TableParser.getDateString(date);
    const parsed = await this.loadMonth(monthStr);
    return parsed.entriesByDate.get(dateStr) || [];
  }
  /**
   * Load entries for today
   */
  async loadTodayEntries() {
    return this.loadEntriesForDate(new Date());
  }
  /**
   * Save a new entry
   */
  async createEntry(entry) {
    const monthStr = entry.date.substring(0, 7);
    const startDateTime = TableParser.parseDateTime(entry.start);
    const endDateTime = TableParser.parseDateTime(entry.end);
    if (!startDateTime || !endDateTime) {
      throw new Error(`Invalid datetime format. Expected "YYYY-MM-DD HH:mm". Got start="${entry.start}", end="${entry.end}"`);
    }
    const durationMinutes = Math.round((endDateTime.getTime() - startDateTime.getTime()) / 6e4);
    const fullEntry = {
      ...entry,
      startDateTime,
      endDateTime,
      durationMinutes,
      lineNumber: 0
      // Row index will be set after save
    };
    const existingEntries = await this.loadEntriesForDate(startDateTime);
    if (this.hasOverlap(fullEntry, existingEntries)) {
      throw new Error("Entry overlaps with an existing time entry");
    }
    const parsed = await this.loadMonth(monthStr);
    const allEntries = [...parsed.entries, fullEntry];
    await this.writeMonthFile(monthStr, allEntries);
    this.invalidateMonth(monthStr);
    new import_obsidian3.Notice("Time entry created");
    return fullEntry;
  }
  /**
   * Update an existing entry
   */
  async updateEntry(oldEntry, newEntry) {
    const oldMonthStr = oldEntry.date.substring(0, 7);
    const updatedEntry = {
      ...oldEntry,
      ...newEntry
    };
    if (newEntry.start || newEntry.end || newEntry.date) {
      const startDateTime = TableParser.parseDateTime(updatedEntry.start);
      const endDateTime = TableParser.parseDateTime(updatedEntry.end);
      if (!startDateTime || !endDateTime) {
        throw new Error("Invalid datetime format");
      }
      updatedEntry.startDateTime = startDateTime;
      updatedEntry.endDateTime = endDateTime;
      updatedEntry.durationMinutes = Math.round(
        (endDateTime.getTime() - startDateTime.getTime()) / 6e4
      );
      updatedEntry.date = TableParser.getDateString(startDateTime);
    }
    const newMonthStr = updatedEntry.date.substring(0, 7);
    const monthChanged = oldMonthStr !== newMonthStr;
    const existingEntries = await this.loadEntriesForDate(updatedEntry.startDateTime);
    const otherEntries = existingEntries.filter((e) => !this.isSameEntry(e, oldEntry));
    if (this.hasOverlap(updatedEntry, otherEntries)) {
      throw new Error("Entry overlaps with an existing time entry");
    }
    if (monthChanged) {
      Logger.log("Month changed from", oldMonthStr, "to", newMonthStr);
      const oldParsed = await this.loadMonth(oldMonthStr);
      const oldEntries = oldParsed.entries.filter((e) => !this.isSameEntry(e, oldEntry));
      await this.writeMonthFile(oldMonthStr, oldEntries);
      this.invalidateMonth(oldMonthStr);
      const newParsed = await this.loadMonth(newMonthStr);
      const newEntries = [...newParsed.entries, updatedEntry];
      await this.writeMonthFile(newMonthStr, newEntries);
      this.invalidateMonth(newMonthStr);
    } else {
      const parsed = await this.loadMonth(oldMonthStr);
      const entries = parsed.entries.map(
        (e) => this.isSameEntry(e, oldEntry) ? updatedEntry : e
      );
      await this.writeMonthFile(oldMonthStr, entries);
      this.invalidateMonth(oldMonthStr);
    }
    new import_obsidian3.Notice("Time entry updated");
    return updatedEntry;
  }
  /**
   * Delete an entry
   */
  async deleteEntry(entry) {
    const monthStr = entry.date.substring(0, 7);
    const parsed = await this.loadMonth(monthStr);
    const entries = parsed.entries.filter((e) => !this.isSameEntry(e, entry));
    await this.writeMonthFile(monthStr, entries);
    this.invalidateMonth(monthStr);
    new import_obsidian3.Notice("Time entry deleted");
  }
  /**
   * Write a month file with the given entries
   */
  async writeMonthFile(monthStr, entries) {
    const file = await this.getOrCreateMonthFile(monthStr);
    const content3 = TableParser.generateMonthFile(entries, monthStr, this.settings.hideTablesInPreview);
    await this.vault.modify(file, content3);
  }
  /**
   * Check if two entries are the same (based on start time and description)
   */
  isSameEntry(a, b) {
    return a.startDateTime.getTime() === b.startDateTime.getTime() && a.endDateTime.getTime() === b.endDateTime.getTime() && a.description === b.description;
  }
  /**
   * Check if an entry overlaps with existing entries
   */
  hasOverlap(newEntry, existingEntries) {
    return existingEntries.some((existing) => {
      if (this.isSameEntry(existing, newEntry)) {
        return false;
      }
      return newEntry.startDateTime < existing.endDateTime && newEntry.endDateTime > existing.startDateTime;
    });
  }
  /**
   * Find all overlapping entries and classify each overlap type
   * - startOverlap: First entry where our START falls inside
   * - endOverlap: First entry where our END falls inside
   * - encompassedEntry: First entry we fully encompass
   */
  async findOverlaps(start, end, excludeEntry) {
    const entries = await this.loadDateRange(start, end);
    Logger.log("DataManager.findOverlaps:", {
      start: start.toISOString(),
      end: end.toISOString(),
      entriesLoaded: entries.length
    });
    let startOverlap = null;
    let endOverlap = null;
    let encompassedEntry = null;
    for (const entry of entries) {
      if (excludeEntry && this.isSameEntry(entry, excludeEntry))
        continue;
      const overlaps = start < entry.endDateTime && end > entry.startDateTime;
      if (!overlaps) {
        Logger.log("  vs", entry.start, "-", entry.end, ": no overlap");
        continue;
      }
      const startInside = start >= entry.startDateTime && start < entry.endDateTime;
      const endInside = end > entry.startDateTime && end <= entry.endDateTime;
      Logger.log(
        "  vs",
        entry.start,
        "-",
        entry.end,
        ":",
        startInside ? "START_INSIDE" : "",
        endInside ? "END_INSIDE" : "",
        !startInside && !endInside ? "ENCOMPASSED" : ""
      );
      if (startInside && !startOverlap) {
        startOverlap = entry;
      }
      if (endInside && !endOverlap) {
        endOverlap = entry;
      }
      if (!startInside && !endInside && !encompassedEntry) {
        encompassedEntry = entry;
      }
    }
    return { startOverlap, endOverlap, encompassedEntry };
  }
  /**
   * Find adjacent entries (previous entry ending before start, next entry starting after end)
   * Used for "magnet" snap feature in entry modal
   */
  async findAdjacentEntries(start, end, excludeEntry) {
    const searchStart = new Date(start);
    searchStart.setDate(searchStart.getDate() - 1);
    const searchEnd = new Date(end);
    searchEnd.setDate(searchEnd.getDate() + 1);
    const entries = await this.loadDateRange(searchStart, searchEnd);
    let previous3 = null;
    let next = null;
    for (const entry of entries) {
      if (excludeEntry && this.isSameEntry(entry, excludeEntry))
        continue;
      if (entry.endDateTime <= start) {
        if (!previous3 || entry.endDateTime > previous3.endDateTime) {
          previous3 = entry;
        }
      }
      if (entry.startDateTime >= end) {
        if (!next || entry.startDateTime < next.startDateTime) {
          next = entry;
        }
      }
    }
    Logger.log("DataManager.findAdjacentEntries:", {
      start: start.toISOString(),
      end: end.toISOString(),
      previous: previous3 ? `${previous3.start}-${previous3.end}` : null,
      next: next ? `${next.start}-${next.end}` : null
    });
    return { previous: previous3, next };
  }
  /**
   * Get all unique projects from entries
   */
  async getAllProjects() {
    const projects = /* @__PURE__ */ new Set();
    const now = new Date();
    const thisMonth = TableParser.getMonthString(now);
    const lastMonth = TableParser.getMonthString(
      new Date(now.getFullYear(), now.getMonth() - 1, 1)
    );
    for (const monthStr of [thisMonth, lastMonth]) {
      const parsed = await this.loadMonth(monthStr);
      for (const entry of parsed.entries) {
        if (entry.project) {
          projects.add(entry.project);
        }
      }
    }
    return Array.from(projects).sort();
  }
  /**
   * Get all unique tags from entries (deprecated - returns empty)
   */
  async getAllTags() {
    return [];
  }
};
var DataManager = _DataManager;
// Limit cache size to prevent unbounded memory growth
DataManager.MAX_CACHED_MONTHS = 24;

// src/views/TimelineView.ts
var import_obsidian5 = require("obsidian");

// src/modals/EntryModal.ts
var import_obsidian4 = require("obsidian");
var EntryModal = class extends import_obsidian4.Modal {
  constructor(app, settings, dataManager, data, onSave) {
    super(app);
    // Dropdown references for cascading updates
    this.projectDropdown = null;
    this.activityDropdown = null;
    // Cleanup handlers
    this.cleanupHandlers = [];
    // Input references for updating
    this.endDateInput = null;
    this.endTimeInput = null;
    this.durationInput = null;
    this.startDateInput = null;
    this.startTimeInput = null;
    // Overlap validation UI
    this.saveButton = null;
    this.warningBanner = null;
    this.startOverlap = null;
    this.endOverlap = null;
    this.encompassedEntry = null;
    // Snap hints for adjacent entries
    this.previousEntry = null;
    this.nextEntry = null;
    this.startSnapHint = null;
    this.endSnapHint = null;
    // Validation request counter to prevent race conditions
    this.validationRequestId = 0;
    // Duration validation state
    this.hasInvalidDuration = false;
    this.settings = settings;
    this.dataManager = dataManager;
    this.data = data;
    this.onSave = onSave;
    if (data.mode === "edit" && data.entry) {
      this.startDateValue = TableParser.getDateString(data.entry.startDateTime);
      this.startTimeValue = data.entry.start;
      this.endDateValue = TableParser.getDateString(data.entry.endDateTime);
      this.endTimeValue = data.entry.end;
      this.durationValue = this.formatDurationMinutes(data.entry.durationMinutes);
      this.descriptionValue = data.entry.description;
      this.clientValue = data.entry.client;
      this.projectValue = this.resolveProjectName(data.entry.project);
      this.activityValue = this.resolveActivityName(data.entry.activity);
      this.linkedNoteValue = data.entry.linkedNote || "";
    } else {
      const date = data.date || new Date();
      this.startDateValue = TableParser.getDateString(date);
      this.startTimeValue = data.startTime || this.getCurrentTimeRounded();
      if (data.endTime) {
        const startMins = this.timeToMinutes(this.startTimeValue);
        const endMins = this.timeToMinutes(data.endTime);
        if (endMins < startMins) {
          const nextDay = new Date(date);
          nextDay.setDate(nextDay.getDate() + 1);
          this.endDateValue = TableParser.getDateString(nextDay);
        } else {
          this.endDateValue = this.startDateValue;
        }
        this.endTimeValue = data.endTime;
      } else {
        this.endDateValue = this.startDateValue;
        this.endTimeValue = this.addHourToTime(this.startTimeValue);
      }
      this.durationValue = this.calculateDurationFromDates();
      this.descriptionValue = "";
      const activeClients = this.settings.clients.filter((c) => !c.archived);
      this.clientValue = activeClients.length > 0 ? activeClients[0].id : "";
      this.projectValue = this.resolveProjectName(this.settings.defaultProject);
      this.activityValue = this.resolveActivityName(this.settings.defaultActivity);
      this.linkedNoteValue = "";
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("time-tracker-entry-modal");
    const title = this.data.mode === "edit" ? "Edit Time Entry" : "New Time Entry";
    contentEl.createEl("h2", { text: title });
    const startRow = contentEl.createDiv("time-row");
    const startSetting = new import_obsidian4.Setting(startRow).setName("Start").addText((text5) => {
      this.startDateInput = text5;
      text5.setValue(this.startDateValue);
      text5.inputEl.type = "date";
      text5.onChange((value) => {
        this.startDateValue = value;
        this.recalculateDuration();
        this.validateOverlap();
        this.findAdjacentEntries();
      });
    }).addText((text5) => {
      this.startTimeInput = text5;
      text5.setValue(this.startTimeValue);
      text5.inputEl.type = "time";
      text5.onChange((value) => {
        this.startTimeValue = value;
        this.recalculateDuration();
        this.validateOverlap();
        this.findAdjacentEntries();
      });
    });
    this.startSnapHint = startSetting.controlEl.createEl("button", {
      cls: "time-magnet-btn",
      text: "\u{1F9F2}"
    });
    this.startSnapHint.style.display = "none";
    this.startSnapHint.addEventListener("click", (e) => {
      e.preventDefault();
      this.snapStartToPrevious();
    });
    new import_obsidian4.Setting(contentEl).setName("Duration").addText((text5) => {
      this.durationInput = text5;
      text5.setValue(this.durationValue);
      text5.setPlaceholder("1h 30m");
      text5.inputEl.addClass("duration-input");
      text5.onChange((value) => {
        this.durationValue = value;
        this.updateEndFromDuration();
        this.validateOverlap();
      });
    });
    const endRow = contentEl.createDiv("time-row");
    const endSetting = new import_obsidian4.Setting(endRow).setName("End").addText((text5) => {
      this.endDateInput = text5;
      text5.setValue(this.endDateValue);
      text5.inputEl.type = "date";
      text5.onChange((value) => {
        this.endDateValue = value;
        this.recalculateDuration();
        this.validateOverlap();
        this.findAdjacentEntries();
      });
    }).addText((text5) => {
      this.endTimeInput = text5;
      text5.setValue(this.endTimeValue);
      text5.inputEl.type = "time";
      text5.onChange((value) => {
        this.endTimeValue = value;
        this.recalculateDuration();
        this.validateOverlap();
        this.findAdjacentEntries();
      });
    });
    this.endSnapHint = endSetting.controlEl.createEl("button", {
      cls: "time-magnet-btn",
      text: "\u{1F9F2}"
    });
    this.endSnapHint.style.display = "none";
    this.endSnapHint.addEventListener("click", (e) => {
      e.preventDefault();
      this.snapEndToNext();
    });
    this.warningBanner = contentEl.createDiv("overlap-warning-banner");
    this.warningBanner.style.display = "none";
    new import_obsidian4.Setting(contentEl).setName("Client").addDropdown((dropdown) => {
      for (const client of this.settings.clients) {
        if (!client.archived) {
          dropdown.addOption(client.id, client.name);
        }
      }
      dropdown.setValue(this.clientValue);
      dropdown.onChange((value) => {
        this.clientValue = value;
        this.updateProjectDropdown();
        this.updateActivityDropdown();
      });
    });
    new import_obsidian4.Setting(contentEl).setName("Project").addDropdown((dropdown) => {
      this.projectDropdown = dropdown;
      this.populateProjectDropdown(dropdown);
      dropdown.setValue(this.projectValue);
      dropdown.onChange((value) => {
        this.projectValue = value;
      });
    });
    new import_obsidian4.Setting(contentEl).setName("Activity").addDropdown((dropdown) => {
      this.activityDropdown = dropdown;
      this.populateActivityDropdown(dropdown);
      dropdown.setValue(this.activityValue);
      dropdown.onChange((value) => {
        this.activityValue = value;
      });
    });
    const maxLen = this.settings.descriptionMaxLength;
    const descSetting = new import_obsidian4.Setting(contentEl);
    const descLabel = descSetting.nameEl;
    descLabel.setText("Description ");
    const counterEl = descLabel.createSpan("description-counter");
    const updateCounter = (len) => {
      if (maxLen > 0) {
        counterEl.setText(`(${len}/${maxLen})`);
        counterEl.toggleClass("is-over-limit", len > maxLen);
        counterEl.toggleClass("is-near-limit", len > maxLen * 0.8 && len <= maxLen);
      }
    };
    updateCounter(this.descriptionValue.length);
    descSetting.addTextArea((text5) => {
      text5.setValue(this.descriptionValue);
      text5.setPlaceholder("What did you work on?");
      text5.inputEl.rows = 3;
      text5.onChange((value) => {
        let cleaned = value;
        if (maxLen > 0 && cleaned.length > maxLen) {
          cleaned = cleaned.substring(0, maxLen);
          text5.setValue(cleaned);
        }
        this.descriptionValue = cleaned;
        updateCounter(cleaned.length);
      });
    });
    const linkedNoteSetting = new import_obsidian4.Setting(contentEl).setName("Linked Note");
    let linkedNoteInput;
    linkedNoteSetting.addText((text5) => {
      linkedNoteInput = text5;
      text5.setValue(this.linkedNoteValue);
      text5.setPlaceholder("path/to/note");
      text5.onChange((value) => {
        this.linkedNoteValue = value;
      });
    });
    linkedNoteSetting.addButton((btn) => {
      btn.setButtonText("Browse").setTooltip("Select an existing note").onClick(() => {
        new NoteSuggestModal(this.app, (file) => {
          const path2 = file.path.replace(/\.md$/, "");
          linkedNoteInput.setValue(path2);
          this.linkedNoteValue = path2;
        }).open();
      });
    });
    linkedNoteSetting.addButton((btn) => {
      btn.setButtonText("Create New").setTooltip("Create a new linked note").onClick(() => {
        this.showCreateNoteInput(contentEl, linkedNoteInput);
      });
    });
    const buttonRow = contentEl.createDiv("modal-button-row");
    if (this.data.mode === "edit") {
      const deleteBtn = buttonRow.createEl("button", {
        text: "Delete",
        cls: "mod-warning"
      });
      deleteBtn.addEventListener("click", () => this.handleDelete());
    }
    buttonRow.createDiv("button-spacer");
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel"
    });
    cancelBtn.addEventListener("click", () => this.close());
    this.saveButton = buttonRow.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    this.saveButton.addEventListener("click", () => this.handleSave());
    this.validateOverlap();
    this.findAdjacentEntries();
  }
  onClose() {
    for (const handler of this.cleanupHandlers) {
      handler();
    }
    this.cleanupHandlers = [];
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Handle save button click
   */
  async handleSave() {
    if (!this.startDateValue || !this.startTimeValue || !this.endDateValue || !this.endTimeValue) {
      Logger.error("EntryModal: Missing required fields");
      return;
    }
    if (!this.clientValue) {
      new import_obsidian4.Notice("Please select a client");
      return;
    }
    if (!/^\d{4}-\d{2}-\d{2}$/.test(this.startDateValue) || !/^\d{4}-\d{2}-\d{2}$/.test(this.endDateValue)) {
      Logger.error("EntryModal: Invalid date format");
      return;
    }
    const startDateTime = new Date(`${this.startDateValue}T${this.startTimeValue}`);
    const endDateTime = new Date(`${this.endDateValue}T${this.endTimeValue}`);
    if (endDateTime <= startDateTime) {
      new import_obsidian4.Notice("End time must be after start time");
      return;
    }
    const startForStorage = `${this.startDateValue} ${this.startTimeValue}`;
    const endForStorage = `${this.endDateValue} ${this.endTimeValue}`;
    Logger.log("Saving entry:", {
      date: this.startDateValue,
      start: startForStorage,
      end: endForStorage
    });
    try {
      if (this.data.mode === "edit" && this.data.entry) {
        await this.dataManager.updateEntry(this.data.entry, {
          date: this.startDateValue,
          start: startForStorage,
          end: endForStorage,
          description: this.descriptionValue,
          client: this.clientValue,
          project: this.projectValue || void 0,
          activity: this.activityValue || void 0,
          linkedNote: this.linkedNoteValue || void 0
        });
      } else {
        await this.dataManager.createEntry({
          date: this.startDateValue,
          start: startForStorage,
          end: endForStorage,
          description: this.descriptionValue,
          client: this.clientValue,
          project: this.projectValue || void 0,
          activity: this.activityValue || void 0,
          linkedNote: this.linkedNoteValue || void 0
        });
      }
      this.onSave();
      this.close();
    } catch (error) {
      Logger.error("EntryModal: Error saving entry:", error);
    }
  }
  /**
   * Handle delete button click
   */
  async handleDelete() {
    if (this.data.mode !== "edit" || !this.data.entry) {
      return;
    }
    const confirmed = confirm("Are you sure you want to delete this entry?");
    if (!confirmed) {
      return;
    }
    try {
      await this.dataManager.deleteEntry(this.data.entry);
      this.onSave();
      this.close();
    } catch (error) {
      Logger.error("EntryModal: Error deleting entry:", error);
    }
  }
  /**
   * Get current time rounded to nearest 15 minutes
   */
  getCurrentTimeRounded() {
    const now = new Date();
    const minutes = Math.round(now.getMinutes() / 15) * 15;
    const hours = now.getHours() + (minutes >= 60 ? 1 : 0);
    const adjustedMinutes = minutes % 60;
    return `${hours.toString().padStart(2, "0")}:${adjustedMinutes.toString().padStart(2, "0")}`;
  }
  /**
   * Add one hour to a time string
   */
  addHourToTime(time) {
    const [hours, minutes] = time.split(":").map(Number);
    const newHours = (hours + 1) % 24;
    return `${newHours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
  }
  /**
   * Resolve a project ID or name to the actual project name
   * Handles both old lowercase ID format and new name format
   */
  resolveProjectName(projectIdOrName) {
    if (!projectIdOrName)
      return "";
    const byName = this.settings.projects.find((p) => p.name === projectIdOrName);
    if (byName)
      return byName.name;
    const byId = this.settings.projects.find((p) => p.id === projectIdOrName);
    if (byId)
      return byId.name;
    return projectIdOrName;
  }
  /**
   * Resolve an activity ID or name to the actual activity name
   * Handles both lowercase ID format and display name format
   */
  resolveActivityName(activityIdOrName) {
    if (!activityIdOrName)
      return "";
    const byName = this.settings.activities.find((a) => a.name === activityIdOrName);
    if (byName)
      return byName.name;
    const byId = this.settings.activities.find((a) => a.id === activityIdOrName);
    if (byId)
      return byId.name;
    return activityIdOrName;
  }
  /**
   * Convert HH:mm time string to minutes since midnight
   */
  timeToMinutes(time) {
    const [h, m] = time.split(":").map(Number);
    return h * 60 + m;
  }
  /**
   * Format duration in minutes to "Xh Ym" string
   */
  formatDurationMinutes(minutes) {
    if (minutes < 0)
      return "0m";
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    if (h === 0)
      return `${m}m`;
    if (m === 0)
      return `${h}h`;
    return `${h}h ${m}m`;
  }
  /**
   * Calculate duration from current start/end date+time values
   */
  calculateDurationFromDates() {
    const start = new Date(`${this.startDateValue}T${this.startTimeValue}`);
    const end = new Date(`${this.endDateValue}T${this.endTimeValue}`);
    const diffMs = end.getTime() - start.getTime();
    const diffMins = Math.round(diffMs / 6e4);
    return this.formatDurationMinutes(diffMins);
  }
  /**
   * Recalculate and update duration display when dates/times change
   */
  recalculateDuration() {
    const start = new Date(`${this.startDateValue}T${this.startTimeValue}`);
    const end = new Date(`${this.endDateValue}T${this.endTimeValue}`);
    const diffMs = end.getTime() - start.getTime();
    const diffMins = Math.round(diffMs / 6e4);
    this.hasInvalidDuration = diffMins <= 0;
    this.durationValue = this.formatDurationMinutes(diffMins);
    if (this.durationInput) {
      this.durationInput.setValue(this.durationValue);
      this.durationInput.inputEl.toggleClass("time-input-error", this.hasInvalidDuration);
    }
    this.updateSaveButtonState();
  }
  /**
   * Update end date/time based on start + duration
   */
  updateEndFromDuration() {
    const durationMins = this.parseDurationToMinutes(this.durationValue);
    if (durationMins <= 0)
      return;
    const start = new Date(`${this.startDateValue}T${this.startTimeValue}`);
    const end = new Date(start.getTime() + durationMins * 6e4);
    this.endDateValue = TableParser.getDateString(end);
    this.endTimeValue = `${end.getHours().toString().padStart(2, "0")}:${end.getMinutes().toString().padStart(2, "0")}`;
    if (this.endDateInput) {
      this.endDateInput.setValue(this.endDateValue);
    }
    if (this.endTimeInput) {
      this.endTimeInput.setValue(this.endTimeValue);
    }
  }
  /**
   * Parse duration string to minutes
   * Accepts: "1h 30m", "1h30m", "90m", "1.5h", "1h", "30m"
   */
  parseDurationToMinutes(duration) {
    const cleaned = duration.toLowerCase().trim();
    const hhmm = cleaned.match(/(\d+)\s*h\s*(\d+)\s*m/);
    if (hhmm) {
      return parseInt(hhmm[1]) * 60 + parseInt(hhmm[2]);
    }
    const hOnly = cleaned.match(/^(\d+(?:\.\d+)?)\s*h$/);
    if (hOnly) {
      return Math.round(parseFloat(hOnly[1]) * 60);
    }
    const mOnly = cleaned.match(/^(\d+)\s*m$/);
    if (mOnly) {
      return parseInt(mOnly[1]);
    }
    const plain = cleaned.match(/^(\d+)$/);
    if (plain) {
      return parseInt(plain[1]);
    }
    return 0;
  }
  /**
   * Show the create note input UI
   */
  showCreateNoteInput(contentEl, linkedNoteInput) {
    const createNoteRow = contentEl.createDiv("create-note-row");
    const maxLength = 80;
    const defaultName = `${this.startDateValue}-`;
    const nameInput = createNoteRow.createEl("input", {
      type: "text",
      placeholder: "note-name",
      cls: "create-note-slug",
      value: defaultName
    });
    nameInput.maxLength = maxLength;
    const counterSpan = createNoteRow.createSpan("create-note-counter");
    counterSpan.setText(`${defaultName.length}/${maxLength}`);
    nameInput.addEventListener("input", () => {
      const cursorPos = nameInput.selectionStart || 0;
      nameInput.value = nameInput.value.toLowerCase().replace(/[^a-z0-9-]/g, "-").replace(/-+/g, "-");
      nameInput.selectionStart = nameInput.selectionEnd = Math.min(cursorPos, nameInput.value.length);
      counterSpan.setText(`${nameInput.value.length}/${maxLength}`);
    });
    const createBtn = createNoteRow.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    const cancelBtn = createNoteRow.createEl("button", {
      text: "Cancel"
    });
    createBtn.addEventListener("click", async () => {
      const noteName = nameInput.value.trim().replace(/^-+|-+$/g, "");
      if (!noteName) {
        new import_obsidian4.Notice("Please enter a note name");
        return;
      }
      try {
        const notePath = await this.createLinkedNote(noteName);
        linkedNoteInput.setValue(notePath);
        this.linkedNoteValue = notePath;
        createNoteRow.remove();
        new import_obsidian4.Notice("Note created!");
      } catch (err) {
        new import_obsidian4.Notice(`Failed to create note: ${err}`);
      }
    });
    cancelBtn.addEventListener("click", () => {
      createNoteRow.remove();
    });
    nameInput.focus();
    nameInput.selectionStart = nameInput.selectionEnd = nameInput.value.length;
  }
  /**
   * Create a linked note in the Notes subfolder
   */
  async createLinkedNote(slug) {
    const vault = this.app.vault;
    const notesFolder = `${this.settings.timeTrackingFolder}/Notes`;
    const notePath = `${notesFolder}/${slug}.md`;
    const folder = vault.getAbstractFileByPath(notesFolder);
    if (!folder) {
      await vault.createFolder(notesFolder);
    }
    const existing = vault.getAbstractFileByPath(notePath);
    if (existing) {
      throw new Error("Note already exists");
    }
    const content3 = this.generateNoteTemplate(slug);
    await vault.create(notePath, content3);
    return `${notesFolder}/${slug}`;
  }
  /**
   * Generate template content for a new linked note
   * Loosely coupled - no properties that would need updating if entry changes
   */
  generateNoteTemplate(_noteName) {
    return "";
  }
  /**
   * Populate project dropdown with projects for the selected client
   */
  populateProjectDropdown(dropdown) {
    dropdown.selectEl.empty();
    dropdown.addOption("", "(No project)");
    for (const project of this.settings.projects) {
      if (!project.archived && project.clientId === this.clientValue) {
        dropdown.addOption(project.name, project.name);
      }
    }
  }
  /**
   * Update project dropdown when client changes
   */
  updateProjectDropdown() {
    if (!this.projectDropdown)
      return;
    this.populateProjectDropdown(this.projectDropdown);
    const currentProject = this.settings.projects.find(
      (p) => p.name === this.projectValue && p.clientId === this.clientValue
    );
    if (!currentProject) {
      this.projectValue = "";
    }
    this.projectDropdown.setValue(this.projectValue);
  }
  /**
   * Populate activity dropdown with activities for the selected client
   */
  populateActivityDropdown(dropdown) {
    dropdown.selectEl.empty();
    dropdown.addOption("", "(No activity)");
    for (const activity of this.settings.activities) {
      if (activity.clientId === this.clientValue) {
        dropdown.addOption(activity.name, activity.name);
      }
    }
  }
  /**
   * Update activity dropdown when client changes
   */
  updateActivityDropdown() {
    if (!this.activityDropdown)
      return;
    this.populateActivityDropdown(this.activityDropdown);
    const currentActivity = this.settings.activities.find(
      (a) => a.name === this.activityValue && a.clientId === this.clientValue
    );
    if (!currentActivity) {
      this.activityValue = "";
    }
    this.activityDropdown.setValue(this.activityValue);
  }
  /**
   * Validate overlap with existing entries and update UI
   * Uses request ID to prevent race conditions from concurrent async calls
   */
  async validateOverlap() {
    const requestId = ++this.validationRequestId;
    const startDate = this.startDateInput ? this.startDateInput.getValue() : this.startDateValue;
    const startTime = this.startTimeInput ? this.startTimeInput.getValue() : this.startTimeValue;
    const endDate = this.endDateInput ? this.endDateInput.getValue() : this.endDateValue;
    const endTime = this.endTimeInput ? this.endTimeInput.getValue() : this.endTimeValue;
    const startDateTime = new Date(`${startDate}T${startTime}`);
    const endDateTime = new Date(`${endDate}T${endTime}`);
    if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
      Logger.log("EntryModal: Invalid dates, skipping overlap check");
      if (requestId !== this.validationRequestId)
        return;
      this.startOverlap = null;
      this.endOverlap = null;
      this.encompassedEntry = null;
      this.updateOverlapUI();
      return;
    }
    Logger.log("EntryModal: Checking conflicts for", {
      start: startDateTime.toISOString(),
      end: endDateTime.toISOString(),
      requestId
    });
    const excludeEntry = this.data.mode === "edit" ? this.data.entry : void 0;
    const result = await this.dataManager.findOverlaps(startDateTime, endDateTime, excludeEntry);
    if (requestId !== this.validationRequestId) {
      Logger.log("EntryModal: Discarding stale validation result", { requestId, currentId: this.validationRequestId });
      return;
    }
    this.startOverlap = result.startOverlap;
    this.endOverlap = result.endOverlap;
    this.encompassedEntry = result.encompassedEntry;
    Logger.log("EntryModal: startOverlap =", this.startOverlap ? `${this.startOverlap.start} - ${this.startOverlap.end}` : "null");
    Logger.log("EntryModal: endOverlap =", this.endOverlap ? `${this.endOverlap.start} - ${this.endOverlap.end}` : "null");
    Logger.log("EntryModal: encompassedEntry =", this.encompassedEntry ? `${this.encompassedEntry.start} - ${this.encompassedEntry.end}` : "null");
    this.updateOverlapUI();
  }
  /**
   * Update UI based on overlap state
   */
  updateOverlapUI() {
    var _a, _b, _c, _d;
    const hasStartOverlap = this.startOverlap !== null;
    const hasEndOverlap = this.endOverlap !== null;
    const hasEncompassed = this.encompassedEntry !== null;
    const hasAnyConflict = hasStartOverlap || hasEndOverlap || hasEncompassed;
    if ((_a = this.startDateInput) == null ? void 0 : _a.inputEl) {
      this.startDateInput.inputEl.toggleClass("time-input-error", hasStartOverlap);
    }
    if ((_b = this.startTimeInput) == null ? void 0 : _b.inputEl) {
      this.startTimeInput.inputEl.toggleClass("time-input-error", hasStartOverlap);
    }
    if ((_c = this.endDateInput) == null ? void 0 : _c.inputEl) {
      this.endDateInput.inputEl.toggleClass("time-input-error", hasEndOverlap);
    }
    if ((_d = this.endTimeInput) == null ? void 0 : _d.inputEl) {
      this.endTimeInput.inputEl.toggleClass("time-input-error", hasEndOverlap);
    }
    if (this.warningBanner) {
      if (hasAnyConflict) {
        this.warningBanner.style.display = "block";
        this.warningBanner.empty();
        const icon = this.warningBanner.createSpan("overlap-warning-icon");
        icon.setText("\u26A0\uFE0F");
        const textContainer = this.warningBanner.createDiv("overlap-warning-messages");
        if (hasStartOverlap) {
          const entry = this.startOverlap;
          const entryLabel = this.formatEntryLabel(entry);
          const msg = textContainer.createDiv("overlap-message");
          msg.setText(`Start overlaps with ${entryLabel} (${entry.start} \u2013 ${entry.end})`);
        }
        if (hasEndOverlap) {
          const entry = this.endOverlap;
          const entryLabel = this.formatEntryLabel(entry);
          const msg = textContainer.createDiv("overlap-message");
          msg.setText(`End overlaps with ${entryLabel} (${entry.start} \u2013 ${entry.end})`);
        }
        if (hasEncompassed) {
          const entry = this.encompassedEntry;
          const entryLabel = this.formatEntryLabel(entry);
          const msg = textContainer.createDiv("overlap-message");
          msg.setText(`Conflicts with ${entryLabel} (${entry.start} \u2013 ${entry.end})`);
        }
        if (this.hasInvalidDuration) {
          const msg = textContainer.createDiv("overlap-message");
          msg.setText("End time must be after start time");
        }
      } else if (this.hasInvalidDuration) {
        this.warningBanner.style.display = "block";
        this.warningBanner.empty();
        const icon = this.warningBanner.createSpan("overlap-warning-icon");
        icon.setText("\u26A0\uFE0F");
        const textContainer = this.warningBanner.createDiv("overlap-warning-messages");
        const msg = textContainer.createDiv("overlap-message");
        msg.setText("End time must be after start time");
      } else {
        this.warningBanner.style.display = "none";
      }
    }
    this.updateSaveButtonState();
  }
  /**
   * Update save button enabled/disabled state based on all validation
   */
  updateSaveButtonState() {
    const hasAnyConflict = this.startOverlap !== null || this.endOverlap !== null || this.encompassedEntry !== null;
    const cannotSave = hasAnyConflict || this.hasInvalidDuration;
    if (this.saveButton) {
      this.saveButton.disabled = cannotSave;
      this.saveButton.toggleClass("is-disabled", cannotSave);
    }
  }
  /**
   * Get client display name from client ID
   */
  getClientName(clientId) {
    const client = this.settings.clients.find((c) => c.id === clientId);
    return (client == null ? void 0 : client.name) || clientId;
  }
  /**
   * Format entry label as CLIENT > PROJECT > ACTIVITY
   */
  formatEntryLabel(entry) {
    const parts = [];
    const clientName = this.getClientName(entry.client);
    parts.push(clientName);
    if (entry.project) {
      parts.push(entry.project);
    }
    if (entry.activity) {
      parts.push(entry.activity);
    }
    return parts.join(" > ");
  }
  /**
   * Check if two entries are same (helper for filtering)
   */
  isSameEntry(a, b) {
    return a.startDateTime.getTime() === b.startDateTime.getTime() && a.endDateTime.getTime() === b.endDateTime.getTime() && a.description === b.description;
  }
  /**
   * Find adjacent entries (previous ending before start, next starting after end)
   */
  async findAdjacentEntries() {
    const startDateTime = new Date(`${this.startDateValue}T${this.startTimeValue}`);
    const endDateTime = new Date(`${this.endDateValue}T${this.endTimeValue}`);
    if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
      this.previousEntry = null;
      this.nextEntry = null;
      this.updateMagnetButtons();
      return;
    }
    const excludeEntry = this.data.mode === "edit" ? this.data.entry : void 0;
    const { previous: previous3, next } = await this.dataManager.findAdjacentEntries(startDateTime, endDateTime, excludeEntry);
    this.previousEntry = previous3;
    this.nextEntry = next;
    this.updateMagnetButtons();
  }
  /**
   * Update magnet button visibility and tooltips
   */
  updateMagnetButtons() {
    if (this.startSnapHint) {
      if (this.previousEntry) {
        this.startSnapHint.style.display = "inline-flex";
        const prevEnd = this.previousEntry.end;
        const prevClient = this.getClientName(this.previousEntry.client);
        this.startSnapHint.setAttribute("aria-label", `Snap to ${prevEnd} (end of ${prevClient})`);
      } else {
        this.startSnapHint.style.display = "none";
      }
    }
    if (this.endSnapHint) {
      if (this.nextEntry) {
        this.endSnapHint.style.display = "inline-flex";
        const nextStart = this.nextEntry.start;
        const nextClient = this.getClientName(this.nextEntry.client);
        this.endSnapHint.setAttribute("aria-label", `Snap to ${nextStart} (start of ${nextClient})`);
      } else {
        this.endSnapHint.style.display = "none";
      }
    }
  }
  /**
   * Snap start time to end of previous entry
   */
  snapStartToPrevious() {
    if (!this.previousEntry)
      return;
    this.startDateValue = TableParser.getDateString(this.previousEntry.endDateTime);
    this.startTimeValue = this.previousEntry.end;
    if (this.startDateInput) {
      this.startDateInput.setValue(this.startDateValue);
    }
    if (this.startTimeInput) {
      this.startTimeInput.setValue(this.startTimeValue);
    }
    this.recalculateDuration();
    this.validateOverlap();
    this.findAdjacentEntries();
  }
  /**
   * Snap end time to start of next entry
   */
  snapEndToNext() {
    if (!this.nextEntry)
      return;
    this.endDateValue = TableParser.getDateString(this.nextEntry.startDateTime);
    this.endTimeValue = this.nextEntry.start;
    if (this.endDateInput) {
      this.endDateInput.setValue(this.endDateValue);
    }
    if (this.endTimeInput) {
      this.endTimeInput.setValue(this.endTimeValue);
    }
    this.recalculateDuration();
    this.validateOverlap();
    this.findAdjacentEntries();
  }
};
var NoteSuggestModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app, onSelect) {
    super(app);
    this.onSelect = onSelect;
    this.setPlaceholder("Search for a note...");
  }
  getItems() {
    return this.app.vault.getMarkdownFiles();
  }
  getItemText(file) {
    return file.path;
  }
  onChooseItem(file, _evt) {
    this.onSelect(file);
  }
};

// src/views/TimelineView.ts
var TimelineView = class extends import_obsidian5.ItemView {
  constructor(leaf, settings, dataManager) {
    super(leaf);
    // Scroll state
    this.centerDate = new Date();
    this.visibleDaysBuffer = 1;
    // Days to render before/after visible area (prev day, today, next day)
    this.loadedMonths = /* @__PURE__ */ new Set();
    this.entriesByDate = /* @__PURE__ */ new Map();
    // Dimensions
    this.dayHeight = 0;
    // Calculated as 24 * hourHeight
    this.resizeObserver = null;
    // Drag selection state (for creating new entries)
    this.isDragging = false;
    this.dragStartY = 0;
    this.dragCurrentY = 0;
    this.dragStartDate = null;
    this.selectionEl = null;
    this.dragTooltipEl = null;
    // Entry drag state (for moving/resizing existing entries)
    this.entryDragMode = "none";
    this.entryDragEntry = null;
    this.entryDragCard = null;
    this.entryDragStartY = 0;
    this.entryDragOriginalTop = 0;
    this.entryDragOriginalHeight = 0;
    this.entryDragTooltipEl = null;
    /**
     * Handle entry drag movement - mouse version
     */
    this.handleEntryDragMove = (e) => {
      this.updateEntryDragPosition(e.clientY);
    };
    /**
     * Handle entry drag movement - touch version
     */
    this.handleEntryDragMoveTouch = (e) => {
      if (e.touches.length !== 1)
        return;
      e.preventDefault();
      this.updateEntryDragPosition(e.touches[0].clientY);
    };
    /**
     * End entry drag and save changes - mouse version
     */
    this.handleEntryDragEnd = async (e) => {
      document.removeEventListener("mousemove", this.handleEntryDragMove);
      document.removeEventListener("mouseup", this.handleEntryDragEnd);
      await this.finalizeEntryDrag(e.clientY);
    };
    /**
     * End entry drag and save changes - touch version
     */
    this.handleEntryDragEndTouch = async (e) => {
      var _a, _b, _c;
      document.removeEventListener("touchmove", this.handleEntryDragMoveTouch);
      document.removeEventListener("touchend", this.handleEntryDragEndTouch);
      document.removeEventListener("touchcancel", this.handleEntryDragEndTouch);
      const clientY = (_c = (_b = (_a = e.changedTouches) == null ? void 0 : _a[0]) == null ? void 0 : _b.clientY) != null ? _c : this.entryDragStartY;
      await this.finalizeEntryDrag(clientY);
    };
    this.settings = settings;
    this.dataManager = dataManager;
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "\u221E Timeline";
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    this.dayHeight = 24 * this.settings.hourHeight;
    this.centerDate = new Date();
    this.centerDate.setHours(0, 0, 0, 0);
    await this.render();
    requestAnimationFrame(() => {
      const targetOffset = this.visibleDaysBuffer * this.dayHeight + this.settings.dayStartHour * this.settings.hourHeight;
      this.timelineContainer.scrollTop = targetOffset;
      this.updateVisibleDateLabel();
      Logger.log("onOpen: scrolled to today, offset=", targetOffset);
    });
  }
  async onClose() {
    document.removeEventListener("mousemove", this.handleEntryDragMove);
    document.removeEventListener("mouseup", this.handleEntryDragEnd);
    document.removeEventListener("touchmove", this.handleEntryDragMoveTouch);
    document.removeEventListener("touchend", this.handleEntryDragEndTouch);
    document.removeEventListener("touchcancel", this.handleEntryDragEndTouch);
    this.cleanupEntryDrag();
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
  updateSettings(settings) {
    this.settings = settings;
    this.dayHeight = 24 * this.settings.hourHeight;
    if (this.timelineContainer) {
      this.refresh();
    }
  }
  async refresh() {
    var _a, _b;
    Logger.log("refresh: clearing caches and re-rendering");
    const savedScrollTop = (_b = (_a = this.timelineContainer) == null ? void 0 : _a.scrollTop) != null ? _b : 0;
    this.loadedMonths.clear();
    this.entriesByDate.clear();
    await this.loadVisibleRange();
    this.renderVisibleDays();
    if (this.timelineContainer) {
      this.timelineContainer.scrollTop = savedScrollTop;
    }
  }
  /**
   * Main render function - sets up the infinite scroll container
   */
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("time-tracker-timeline");
    this.renderHeader(container);
    this.timelineContainer = container.createDiv("timeline-container");
    this.timelineInner = this.timelineContainer.createDiv("timeline-inner");
    this.rulerContainer = this.timelineInner.createDiv("timeline-ruler");
    this.entriesContainer = this.timelineInner.createDiv("timeline-entries");
    this.entriesContainer.style.setProperty("--tt-hour-height", `${this.settings.hourHeight}px`);
    await this.loadVisibleRange();
    this.renderVisibleDays();
    this.timelineContainer.addEventListener("scroll", () => this.onScroll());
    this.entriesContainer.addEventListener("mousedown", (e) => this.handleDragStart(e));
    this.entriesContainer.addEventListener("mousemove", (e) => this.handleDragMove(e));
    this.entriesContainer.addEventListener("mouseup", (e) => this.handleDragEnd(e));
    this.entriesContainer.addEventListener("mouseleave", (e) => this.handleDragCancel(e));
    this.entriesContainer.addEventListener("touchstart", (e) => this.handleDragStartTouch(e), { passive: false });
    this.entriesContainer.addEventListener("touchmove", (e) => this.handleDragMoveTouch(e), { passive: false });
    this.entriesContainer.addEventListener("touchend", (e) => this.handleDragEndTouch(e), { passive: false });
    this.entriesContainer.addEventListener("touchcancel", () => this.handleDragCancelTouch());
    this.entriesContainer.addEventListener("dblclick", (e) => this.handleTimelineDoubleClick(e));
    this.resizeObserver = new ResizeObserver(() => {
      this.updateVisibleDateLabel();
    });
    this.resizeObserver.observe(this.timelineContainer);
  }
  /**
   * Render the header with controls
   */
  renderHeader(container) {
    const header = container.createDiv("timeline-header");
    const titleSection = header.createDiv("timeline-header-title");
    titleSection.createEl("h2", { text: "\u221E Timeline" });
    this.visibleDateLabel = titleSection.createSpan("timeline-visible-date");
    this.visibleDateLabel.setText("");
    const controls = header.createDiv("timeline-header-controls");
    const todayBtn = controls.createEl("button", {
      text: "Today",
      cls: "timeline-btn",
      attr: { "aria-label": "Go to today" }
    });
    todayBtn.addEventListener("click", () => this.scrollToDate(new Date()));
    const nowBtn = controls.createEl("button", {
      text: "Now",
      cls: "timeline-btn timeline-btn-primary",
      attr: { "aria-label": "Scroll to current time" }
    });
    nowBtn.addEventListener("click", () => this.scrollToNow());
    const prevBtn = controls.createEl("button", {
      cls: "timeline-btn timeline-nav-btn",
      attr: { "aria-label": "Previous day" }
    });
    (0, import_obsidian5.setIcon)(prevBtn, "chevron-left");
    prevBtn.addEventListener("click", () => this.navigateDays(-1));
    const nextBtn = controls.createEl("button", {
      cls: "timeline-btn timeline-nav-btn",
      attr: { "aria-label": "Next day" }
    });
    (0, import_obsidian5.setIcon)(nextBtn, "chevron-right");
    nextBtn.addEventListener("click", () => this.navigateDays(1));
    const jumpBtn = controls.createEl("button", {
      cls: "timeline-btn timeline-nav-btn",
      attr: { "aria-label": "Jump to date" }
    });
    (0, import_obsidian5.setIcon)(jumpBtn, "calendar");
    const hiddenDatePicker = controls.createEl("input", {
      type: "date",
      cls: "timeline-date-picker-hidden"
    });
    hiddenDatePicker.value = this.formatDateForInput(this.centerDate);
    hiddenDatePicker.addEventListener("change", () => {
      const dateValue = hiddenDatePicker.value;
      if (dateValue) {
        const [year, month, day] = dateValue.split("-").map(Number);
        const selectedDate = new Date(year, month - 1, day);
        this.scrollToDate(selectedDate);
      }
    });
    jumpBtn.addEventListener("click", () => {
      var _a;
      ((_a = hiddenDatePicker.showPicker) == null ? void 0 : _a.call(hiddenDatePicker)) || hiddenDatePicker.click();
    });
    const addBtn = controls.createEl("button", {
      cls: "timeline-btn timeline-btn-add",
      attr: { "aria-label": "Add new entry" }
    });
    (0, import_obsidian5.setIcon)(addBtn, "plus");
    addBtn.addEventListener("click", () => {
      const now = new Date();
      const startTime = `${now.getHours().toString().padStart(2, "0")}:${Math.floor(now.getMinutes() / 15) * 15}`.padEnd(5, "0").substring(0, 5);
      this.openCreateModal(now, startTime);
    });
  }
  /**
   * Handle scroll events for infinite loading
   */
  async onScroll() {
    const scrollTop = this.timelineContainer.scrollTop;
    const viewportHeight = this.timelineContainer.clientHeight;
    const totalHeight = (this.visibleDaysBuffer * 2 + 1) * this.dayHeight;
    this.updateVisibleDateLabel();
    const edgeThreshold = this.dayHeight * Math.max(0.5, Math.min(this.visibleDaysBuffer, 3));
    if (scrollTop < edgeThreshold) {
      await this.shiftCenter(-this.visibleDaysBuffer);
    } else if (scrollTop > totalHeight - viewportHeight - edgeThreshold) {
      await this.shiftCenter(this.visibleDaysBuffer);
    }
  }
  /**
   * Shift the center date and re-render while maintaining visual position
   */
  async shiftCenter(days) {
    const oldScrollTop = this.timelineContainer.scrollTop;
    this.centerDate.setDate(this.centerDate.getDate() + days);
    await this.loadVisibleRange();
    this.renderVisibleDays();
    const scrollAdjustment = days * this.dayHeight;
    this.timelineContainer.scrollTop = oldScrollTop - scrollAdjustment;
    Logger.log("Shifted center by", days, "days, new center:", this.centerDate.toDateString());
  }
  /**
   * Update the visible date label based on scroll position
   */
  updateVisibleDateLabel() {
    if (!this.timelineContainer || !this.visibleDateLabel)
      return;
    const scrollTop = this.timelineContainer.scrollTop;
    const viewportHeight = this.timelineContainer.clientHeight;
    const topOffset = scrollTop;
    const bottomOffset = scrollTop + viewportHeight;
    const topDayIndex = Math.floor(topOffset / this.dayHeight) - this.visibleDaysBuffer;
    const bottomDayIndex = Math.floor(bottomOffset / this.dayHeight) - this.visibleDaysBuffer;
    const topDate = new Date(this.centerDate);
    topDate.setDate(topDate.getDate() + topDayIndex);
    const bottomDate = new Date(this.centerDate);
    bottomDate.setDate(bottomDate.getDate() + bottomDayIndex);
    const label = this.formatVisibleDateRange(topDate, bottomDate);
    this.visibleDateLabel.setText(label);
  }
  /**
   * Format the visible date range for display
   */
  formatVisibleDateRange(startDate, endDate) {
    const sameDay = startDate.toDateString() === endDate.toDateString();
    const sameMonth = startDate.getMonth() === endDate.getMonth() && startDate.getFullYear() === endDate.getFullYear();
    if (sameDay) {
      return startDate.toLocaleDateString(void 0, {
        weekday: "short",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    } else if (sameMonth) {
      const startWd = startDate.toLocaleDateString(void 0, { weekday: "short" });
      const endWd = endDate.toLocaleDateString(void 0, { weekday: "short" });
      const month = startDate.toLocaleDateString(void 0, { month: "short" });
      const year = startDate.getFullYear();
      return `${startWd} ${startDate.getDate()} \u2013 ${endWd} ${endDate.getDate()} ${month} ${year}`;
    } else {
      const startPart = startDate.toLocaleDateString(void 0, { weekday: "short", month: "short", day: "numeric" });
      const endPart = endDate.toLocaleDateString(void 0, { weekday: "short", month: "short", day: "numeric", year: "numeric" });
      return `${startPart} \u2013 ${endPart}`;
    }
  }
  /**
   * Load entries for the visible date range
   */
  async loadVisibleRange() {
    const startDate = new Date(this.centerDate);
    startDate.setDate(startDate.getDate() - this.visibleDaysBuffer * 2);
    const endDate = new Date(this.centerDate);
    endDate.setDate(endDate.getDate() + this.visibleDaysBuffer * 2);
    Logger.log(
      "loadVisibleRange: centerDate=",
      this.centerDate.toDateString(),
      "range=",
      startDate.toDateString(),
      "to",
      endDate.toDateString()
    );
    const months = /* @__PURE__ */ new Set();
    const startMonth = TableParser.getMonthString(startDate);
    const endMonth = TableParser.getMonthString(endDate);
    const current = new Date(startDate);
    current.setDate(1);
    while (TableParser.getMonthString(current) <= endMonth) {
      months.add(TableParser.getMonthString(current));
      current.setMonth(current.getMonth() + 1);
    }
    Logger.log("loadVisibleRange: months to check=", Array.from(months));
    for (const month of months) {
      if (!this.loadedMonths.has(month)) {
        Logger.log("loadVisibleRange: loading month", month);
        const parsed = await this.dataManager.loadMonth(month);
        this.loadedMonths.add(month);
        Logger.log("loadVisibleRange: loaded", parsed.entries.length, "entries for", month);
        Logger.log("loadVisibleRange: entriesByDate keys=", Array.from(parsed.entriesByDate.keys()));
        for (const [dateStr, entries] of parsed.entriesByDate) {
          this.entriesByDate.set(dateStr, entries);
          Logger.log("loadVisibleRange: set", dateStr, "with", entries.length, "entries");
        }
      } else {
        Logger.log("loadVisibleRange: month already loaded", month);
      }
    }
  }
  /**
   * Render the visible days in the timeline
   */
  renderVisibleDays() {
    this.rulerContainer.empty();
    this.entriesContainer.empty();
    const totalDays = this.visibleDaysBuffer * 2 + 1;
    const totalHeight = totalDays * this.dayHeight;
    this.timelineInner.style.height = `${totalHeight}px`;
    for (let i = -this.visibleDaysBuffer; i <= this.visibleDaysBuffer; i++) {
      const date = new Date(this.centerDate);
      date.setDate(date.getDate() + i);
      const dayOffset = (i + this.visibleDaysBuffer) * this.dayHeight;
      this.renderDay(date, dayOffset);
    }
  }
  /**
   * Render a single day with ruler and entries
   */
  renderDay(date, topOffset) {
    const dateStr = TableParser.getDateString(date);
    const isToday = this.isToday(date);
    const entries = this.entriesByDate.get(dateStr) || [];
    const totalMinutes = entries.reduce((sum, entry) => sum + entry.durationMinutes, 0);
    const dayHeader = this.entriesContainer.createDiv("timeline-day-header");
    dayHeader.style.top = `${topOffset}px`;
    const dateText = dayHeader.createSpan("day-header-date");
    dateText.setText(this.formatDayHeader(date));
    if (totalMinutes > 0) {
      const totalBadge = dayHeader.createSpan("day-header-total");
      totalBadge.setText(this.formatDuration(totalMinutes));
    }
    if (isToday) {
      dayHeader.addClass("is-today");
    }
    for (let hour = 0; hour < 24; hour++) {
      const hourTop = topOffset + hour * this.settings.hourHeight;
      const hourLabel = this.rulerContainer.createDiv("timeline-hour-label");
      hourLabel.style.top = `${hourTop}px`;
      hourLabel.setText(this.formatHour(hour));
      const hourLine = this.entriesContainer.createDiv("timeline-hour-line");
      hourLine.style.top = `${hourTop}px`;
    }
    if (isToday) {
      const now = new Date();
      const minutesSinceMidnight = now.getHours() * 60 + now.getMinutes();
      const nowTop = topOffset + minutesSinceMidnight / 60 * this.settings.hourHeight;
      const nowLine = this.entriesContainer.createDiv("timeline-now-line");
      nowLine.style.top = `${nowTop}px`;
    }
    if (entries.length > 0) {
      Logger.log("renderDay: rendering", entries.length, "entries for", dateStr);
    }
    for (const entry of entries) {
      this.renderEntryCard(entry, topOffset);
    }
  }
  /**
   * Render an entry card with v5 design: Header + Body + Footer
   * Design spec: 200px/hr, responsive by duration (15m/30m/45m/60m+)
   */
  renderEntryCard(entry, dayTopOffset) {
    const cardStartMinutes = entry.startDateTime.getHours() * 60 + entry.startDateTime.getMinutes();
    const totalDurationMinutes = entry.durationMinutes;
    const top = dayTopOffset + cardStartMinutes / 60 * this.settings.hourHeight;
    const height = Math.max(totalDurationMinutes / 60 * this.settings.hourHeight, 50);
    const card = this.entriesContainer.createDiv("timeline-entry-card");
    card.style.top = `${top}px`;
    card.style.height = `${height}px`;
    card.dataset.entryDate = entry.date;
    card.dataset.entryLine = String(entry.lineNumber);
    const clientColor = this.getClientColor(entry.client);
    card.style.setProperty("--client-color", clientColor);
    const is15m = totalDurationMinutes <= 15;
    if (is15m) {
      card.addClass("entry-15m");
    } else if (totalDurationMinutes <= 30) {
      card.addClass("entry-30m");
    } else if (totalDurationMinutes <= 45) {
      card.addClass("entry-45m");
    } else {
      card.addClass("entry-60m");
    }
    const tooltipParts = [
      entry.description || "(No description)",
      `${entry.start} \u2013 ${entry.end} (${this.formatDuration(entry.durationMinutes)})`,
      `Client: ${this.getClientName(entry.client)}`
    ];
    if (entry.project)
      tooltipParts.push(`Project: ${this.getProjectName(entry.project)}`);
    if (entry.activity)
      tooltipParts.push(`Activity: ${this.getActivityName(entry.activity)}`);
    if (entry.linkedNote)
      tooltipParts.push(`Note: ${entry.linkedNote}`);
    card.setAttribute("title", tooltipParts.join("\n"));
    const header = card.createDiv("entry-card-header");
    const timeText = header.createSpan("entry-time-text");
    timeText.setText(`${entry.start} \u2013 ${entry.end}`);
    const durationBadge = header.createSpan("entry-duration-badge");
    durationBadge.setText(this.formatDuration(entry.durationMinutes));
    if (is15m) {
      const tinyTags = header.createDiv("entry-tiny-tags");
      const clientTag = tinyTags.createSpan("tiny-tag");
      clientTag.setText(this.getClientName(entry.client).substring(0, 3).toUpperCase());
      clientTag.style.setProperty("--tag-color", clientColor);
      if (entry.project) {
        const projectTag = tinyTags.createSpan("tiny-tag");
        projectTag.setText(this.getProjectName(entry.project).substring(0, 3).toUpperCase());
        projectTag.style.setProperty("--tag-color", this.getProjectColor(entry.project));
      }
      if (entry.activity) {
        const activityTag = tinyTags.createSpan("tiny-tag");
        activityTag.setText(this.getActivityName(entry.activity).substring(0, 3).toUpperCase());
        const actColor = this.getActivityColor(entry.activity);
        if (actColor)
          activityTag.style.setProperty("--tag-color", actColor);
      }
      const inlineDesc = header.createSpan("entry-inline-desc");
      inlineDesc.setText(entry.description || "");
    }
    const icons = header.createDiv("entry-header-icons");
    if (entry.linkedNote) {
      const noteIcon = icons.createSpan("entry-icon");
      (0, import_obsidian5.setIcon)(noteIcon, "paperclip");
      noteIcon.setAttribute("title", `Open: ${entry.linkedNote}`);
      noteIcon.addEventListener("click", (e) => {
        e.stopPropagation();
        this.openLinkedNote(entry.linkedNote);
      });
    }
    const editIcon = icons.createSpan("entry-icon");
    (0, import_obsidian5.setIcon)(editIcon, "pencil");
    editIcon.setAttribute("title", "Edit entry");
    editIcon.addEventListener("click", (e) => {
      e.stopPropagation();
      this.openEditModal(entry);
    });
    const deleteIcon = icons.createSpan("entry-icon entry-icon-delete");
    (0, import_obsidian5.setIcon)(deleteIcon, "trash-2");
    deleteIcon.setAttribute("title", "Delete entry");
    deleteIcon.addEventListener("click", (e) => {
      e.stopPropagation();
      this.confirmDeleteEntry(entry);
    });
    if (!is15m) {
      const body = card.createDiv("entry-card-body");
      const desc = body.createDiv("entry-body-desc");
      if (entry.description) {
        desc.textContent = entry.description;
      }
    }
    if (!is15m) {
      const footer = card.createDiv("entry-card-footer");
      const clientSeg = footer.createSpan("powerline-seg");
      clientSeg.setText(this.getClientName(entry.client));
      clientSeg.style.setProperty("--seg-color", clientColor);
      if (entry.project) {
        const projectSeg = footer.createSpan("powerline-seg");
        projectSeg.setText(this.getProjectName(entry.project));
        projectSeg.style.setProperty("--seg-color", this.getProjectColor(entry.project));
      }
      if (entry.activity) {
        const activitySeg = footer.createSpan("powerline-seg");
        activitySeg.setText(this.getActivityName(entry.activity));
        const actColor = this.getActivityColor(entry.activity);
        if (actColor)
          activitySeg.style.setProperty("--seg-color", actColor);
      }
    }
    const resizeBottom = card.createDiv("entry-resize-handle entry-resize-bottom");
    resizeBottom.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      this.startEntryDrag(e, entry, card, "resize-bottom");
    });
    resizeBottom.addEventListener("touchstart", (e) => {
      e.stopPropagation();
      this.startEntryDragTouch(e, entry, card, "resize-bottom");
    }, { passive: false });
    card.addEventListener("mousedown", (e) => {
      const target = e.target;
      if (target.classList.contains("entry-resize-handle"))
        return;
      if (target.closest(".entry-icon"))
        return;
      e.stopPropagation();
      this.startEntryDrag(e, entry, card, "move");
    });
    card.addEventListener("touchstart", (e) => {
      const target = e.target;
      if (target.classList.contains("entry-resize-handle"))
        return;
      if (target.closest(".entry-icon"))
        return;
      e.stopPropagation();
      this.startEntryDragTouch(e, entry, card, "move");
    }, { passive: false });
  }
  /**
   * Start dragging an entry (move or resize) - mouse version
   */
  startEntryDrag(e, entry, card, mode) {
    e.preventDefault();
    this.initEntryDrag(e.clientY, entry, card, mode);
    document.addEventListener("mousemove", this.handleEntryDragMove);
    document.addEventListener("mouseup", this.handleEntryDragEnd);
  }
  /**
   * Start dragging an entry (move or resize) - touch version
   */
  startEntryDragTouch(e, entry, card, mode) {
    if (e.touches.length !== 1)
      return;
    e.preventDefault();
    this.initEntryDrag(e.touches[0].clientY, entry, card, mode);
    document.addEventListener("touchmove", this.handleEntryDragMoveTouch, { passive: false });
    document.addEventListener("touchend", this.handleEntryDragEndTouch);
    document.addEventListener("touchcancel", this.handleEntryDragEndTouch);
  }
  /**
   * Initialize entry drag state (shared by mouse and touch)
   */
  initEntryDrag(clientY, entry, card, mode) {
    this.entryDragMode = mode;
    this.entryDragEntry = entry;
    this.entryDragCard = card;
    this.entryDragStartY = clientY;
    this.entryDragOriginalTop = parseFloat(card.style.top);
    this.entryDragOriginalHeight = parseFloat(card.style.height);
    card.addClass("is-dragging");
    this.entryDragTooltipEl = this.timelineInner.createDiv("timeline-drag-tooltip");
    this.updateEntryDragTooltip();
  }
  /**
   * Update entry position during drag (shared by mouse and touch)
   */
  updateEntryDragPosition(clientY) {
    if (this.entryDragMode === "none" || !this.entryDragCard)
      return;
    const deltaY = clientY - this.entryDragStartY;
    if (this.entryDragMode === "move") {
      const newTop = this.entryDragOriginalTop + deltaY;
      this.entryDragCard.style.top = `${newTop}px`;
    } else if (this.entryDragMode === "resize-top") {
      const newTop = this.entryDragOriginalTop + deltaY;
      const newHeight = this.entryDragOriginalHeight - deltaY;
      if (newHeight >= 30) {
        this.entryDragCard.style.top = `${newTop}px`;
        this.entryDragCard.style.height = `${newHeight}px`;
      }
    } else if (this.entryDragMode === "resize-bottom") {
      const newHeight = this.entryDragOriginalHeight + deltaY;
      if (newHeight >= 30) {
        this.entryDragCard.style.height = `${newHeight}px`;
      }
    }
    this.updateEntryDragTooltip();
  }
  /**
   * Finalize entry drag - calculate new times and save (shared by mouse and touch)
   */
  async finalizeEntryDrag(clientY) {
    if (this.entryDragMode === "none" || !this.entryDragCard || !this.entryDragEntry) {
      this.cleanupEntryDrag();
      return;
    }
    const deltaY = clientY - this.entryDragStartY;
    if (Math.abs(deltaY) < 5) {
      this.cleanupEntryDrag();
      return;
    }
    const entry = this.entryDragEntry;
    const card = this.entryDragCard;
    const newTop = parseFloat(card.style.top);
    const newHeight = parseFloat(card.style.height);
    const newStartMinutes = newTop / this.settings.hourHeight * 60;
    const newDurationMinutes = newHeight / this.settings.hourHeight * 60;
    const dayIndex = Math.floor(newTop / this.dayHeight);
    const minutesInDay = newStartMinutes - dayIndex * 24 * 60;
    const newDate = new Date(this.centerDate);
    newDate.setDate(newDate.getDate() + dayIndex - this.visibleDaysBuffer);
    const startHours = Math.floor(minutesInDay / 60) % 24;
    const startMins = Math.round(minutesInDay % 60 / 15) * 15;
    const endTotalMins = minutesInDay + newDurationMinutes;
    const endHours = Math.floor(endTotalMins / 60) % 24;
    const endMins = Math.round(endTotalMins % 60 / 15) * 15;
    const endDate = new Date(newDate);
    const daysToAdd = Math.floor(endTotalMins / (24 * 60));
    if (daysToAdd > 0) {
      endDate.setDate(endDate.getDate() + daysToAdd);
    }
    const newStartTime = `${startHours.toString().padStart(2, "0")}:${startMins.toString().padStart(2, "0")}`;
    const newEndTime = `${endHours.toString().padStart(2, "0")}:${endMins.toString().padStart(2, "0")}`;
    const newDateStr = TableParser.getDateString(newDate);
    const endDateStr = TableParser.getDateString(endDate);
    const fullStart = `${newDateStr} ${newStartTime}`;
    const fullEnd = `${endDateStr} ${newEndTime}`;
    try {
      await this.dataManager.updateEntry(entry, {
        date: newDateStr,
        start: fullStart,
        end: fullEnd
      });
      await this.refresh();
    } catch (err) {
      Logger.error("Failed to update entry after drag:", err);
      new import_obsidian5.Notice("Failed to move entry. It may overlap with another entry.");
      card.style.top = `${this.entryDragOriginalTop}px`;
      card.style.height = `${this.entryDragOriginalHeight}px`;
    }
    this.cleanupEntryDrag();
  }
  /**
   * Clean up entry drag state
   */
  cleanupEntryDrag() {
    if (this.entryDragCard) {
      this.entryDragCard.removeClass("is-dragging");
    }
    if (this.entryDragTooltipEl) {
      this.entryDragTooltipEl.remove();
      this.entryDragTooltipEl = null;
    }
    this.entryDragMode = "none";
    this.entryDragEntry = null;
    this.entryDragCard = null;
  }
  /**
   * Update the entry drag tooltip with current start/end times
   */
  updateEntryDragTooltip() {
    if (!this.entryDragTooltipEl || !this.entryDragCard)
      return;
    const newTop = parseFloat(this.entryDragCard.style.top);
    const newHeight = parseFloat(this.entryDragCard.style.height);
    const newStartMinutes = newTop / this.settings.hourHeight * 60;
    const newDurationMinutes = newHeight / this.settings.hourHeight * 60;
    const dayIndex = Math.floor(newTop / this.dayHeight);
    const minutesInDay = newStartMinutes - dayIndex * 24 * 60;
    const endMinutesInDay = minutesInDay + newDurationMinutes;
    const startHours = Math.floor(minutesInDay / 60) % 24;
    const startMins = Math.round(minutesInDay % 60 / 15) * 15;
    const endHours = Math.floor(endMinutesInDay / 60) % 24;
    const endMins = Math.round(endMinutesInDay % 60 / 15) * 15;
    const startTime = `${startHours.toString().padStart(2, "0")}:${startMins.toString().padStart(2, "0")}`;
    const endTime = `${endHours.toString().padStart(2, "0")}:${endMins.toString().padStart(2, "0")}`;
    this.entryDragTooltipEl.setText(`${startTime} \u2013 ${endTime}`);
    this.entryDragTooltipEl.style.top = `${newTop + newHeight + 8}px`;
  }
  /**
   * Scroll to a specific date, positioning dayStartHour at the top
   */
  scrollToDate(date) {
    this.centerDate = new Date(date);
    this.centerDate.setHours(0, 0, 0, 0);
    this.loadVisibleRange().then(() => {
      this.renderVisibleDays();
      const targetOffset = this.visibleDaysBuffer * this.dayHeight + this.settings.dayStartHour * this.settings.hourHeight;
      this.timelineContainer.scrollTop = targetOffset;
      this.updateVisibleDateLabel();
    });
  }
  /**
   * Navigate by number of days
   */
  navigateDays(days) {
    const newDate = new Date(this.centerDate);
    newDate.setDate(newDate.getDate() + days);
    this.scrollToDate(newDate);
  }
  /**
   * Scroll to the current time (now line)
   */
  scrollToNow() {
    const now = new Date();
    this.centerDate = new Date(now);
    this.centerDate.setHours(0, 0, 0, 0);
    this.loadVisibleRange().then(() => {
      this.renderVisibleDays();
      const currentHour = now.getHours() + now.getMinutes() / 60;
      const viewportHeight = this.timelineContainer.clientHeight;
      const nowOffset = this.visibleDaysBuffer * this.dayHeight + currentHour * this.settings.hourHeight;
      const targetScroll = nowOffset - viewportHeight / 2;
      this.timelineContainer.scrollTop = Math.max(0, targetScroll);
      this.updateVisibleDateLabel();
    });
  }
  // Helper methods
  isToday(date) {
    const today = new Date();
    return date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth() && date.getDate() === today.getDate();
  }
  formatDayHeader(date) {
    const options = {
      weekday: "long",
      month: "short",
      day: "numeric"
    };
    const formatted = date.toLocaleDateString(void 0, options);
    return this.isToday(date) ? `Today \xB7 ${formatted}` : formatted;
  }
  formatHour(hour) {
    if (this.settings.use24HourFormat) {
      return `${hour.toString().padStart(2, "0")}:00`;
    }
    const h = hour % 12 || 12;
    const ampm = hour < 12 ? "AM" : "PM";
    return `${h} ${ampm}`;
  }
  formatDuration(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    if (hours === 0)
      return `${mins}m`;
    if (mins === 0)
      return `${hours}h`;
    return `${hours}h ${mins}m`;
  }
  formatDateForInput(date) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  getProjectColor(projectId) {
    if (!projectId)
      return "#4f46e5";
    const project = this.settings.projects.find((p) => p.id === projectId || p.name === projectId);
    return (project == null ? void 0 : project.color) || "#4f46e5";
  }
  /**
   * Get color for an activity from settings
   */
  getActivityColor(activityName) {
    const activity = this.settings.activities.find((a) => a.name === activityName || a.id === activityName);
    return activity == null ? void 0 : activity.color;
  }
  /**
   * Get display name for a client from settings
   */
  getClientName(clientId) {
    const client = this.settings.clients.find((c) => c.id === clientId || c.name === clientId);
    return (client == null ? void 0 : client.name) || clientId;
  }
  /**
   * Get color for a client from settings
   */
  getClientColor(clientId) {
    const client = this.settings.clients.find((c) => c.id === clientId || c.name === clientId);
    return (client == null ? void 0 : client.color) || "#4f46e5";
  }
  /**
   * Get display name for a project from settings
   */
  getProjectName(projectId) {
    const project = this.settings.projects.find((p) => p.id === projectId || p.name === projectId);
    return (project == null ? void 0 : project.name) || projectId;
  }
  /**
   * Get display name for an activity from settings
   */
  getActivityName(activityId) {
    const activity = this.settings.activities.find((a) => a.id === activityId || a.name === activityId);
    return (activity == null ? void 0 : activity.name) || activityId;
  }
  /**
   * Open a linked note in Obsidian
   */
  openLinkedNote(notePath) {
    const fullPath = notePath.endsWith(".md") ? notePath : `${notePath}.md`;
    const file = this.app.vault.getAbstractFileByPath(fullPath);
    if (file) {
      this.app.workspace.openLinkText(notePath, "", false);
    } else {
      Logger.warn("Linked note not found:", fullPath);
    }
  }
  // Modal methods
  /**
   * Open modal to edit an existing entry
   */
  openEditModal(entry) {
    Logger.log("Opening edit modal for entry:", entry);
    const data = {
      mode: "edit",
      entry
    };
    const modal = new EntryModal(
      this.app,
      this.settings,
      this.dataManager,
      data,
      () => this.refresh()
    );
    modal.open();
  }
  /**
   * Open modal to create a new entry
   */
  openCreateModal(date, startTime) {
    Logger.log("Opening create modal for date:", date, "time:", startTime);
    const data = {
      mode: "create",
      date,
      startTime
    };
    const modal = new EntryModal(
      this.app,
      this.settings,
      this.dataManager,
      data,
      () => this.refresh()
    );
    modal.open();
  }
  /**
   * Show confirmation dialog and delete entry if confirmed
   */
  confirmDeleteEntry(entry) {
    new ConfirmDeleteModal(this.app, entry, async () => {
      await this.dataManager.deleteEntry(entry);
      this.refresh();
    }).open();
  }
  /**
   * Handle double-click on timeline to create new entry
   */
  handleTimelineDoubleClick(e) {
    const target = e.target;
    if (target.closest(".timeline-entry-card")) {
      return;
    }
    const rect = this.timelineInner.getBoundingClientRect();
    const clickY = e.clientY - rect.top;
    Logger.log("Double-click debug:", {
      clientY: e.clientY,
      rectTop: rect.top,
      clickY,
      dayHeight: this.dayHeight,
      visibleDaysBuffer: this.visibleDaysBuffer,
      centerDate: this.centerDate.toISOString()
    });
    const dayIndex = Math.floor(clickY / this.dayHeight) - this.visibleDaysBuffer;
    const clickedDate = new Date(this.centerDate);
    clickedDate.setDate(clickedDate.getDate() + dayIndex);
    const yWithinDay = clickY % this.dayHeight;
    const hoursFromMidnight = yWithinDay / this.settings.hourHeight;
    const hours = Math.floor(hoursFromMidnight);
    const minutes = Math.round((hoursFromMidnight - hours) * 60 / 15) * 15;
    const startTime = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
    Logger.log("Double-clicked at:", clickedDate.toDateString(), startTime);
    this.openCreateModal(clickedDate, startTime);
  }
  // Drag selection handlers
  /**
   * Handle drag start - begin selecting time range
   */
  handleDragStart(e) {
    const target = e.target;
    if (target.closest(".timeline-entry-card")) {
      return;
    }
    if (e.button !== 0)
      return;
    if (this.isDragging)
      return;
    this.isDragging = true;
    if (this.selectionEl) {
      this.selectionEl.remove();
      this.selectionEl = null;
    }
    const rect = this.timelineInner.getBoundingClientRect();
    this.dragStartY = e.clientY - rect.top;
    this.dragCurrentY = this.dragStartY;
    const dayIndex = Math.floor(this.dragStartY / this.dayHeight) - this.visibleDaysBuffer;
    this.dragStartDate = new Date(this.centerDate);
    this.dragStartDate.setDate(this.dragStartDate.getDate() + dayIndex);
    this.selectionEl = this.timelineInner.createDiv("timeline-drag-selection");
    this.dragTooltipEl = this.timelineInner.createDiv("timeline-drag-tooltip");
    this.updateSelectionElement();
    e.preventDefault();
  }
  /**
   * Handle drag move - update selection visual
   */
  handleDragMove(e) {
    if (!this.isDragging || !this.selectionEl)
      return;
    const rect = this.timelineInner.getBoundingClientRect();
    this.dragCurrentY = e.clientY - rect.top;
    this.updateSelectionElement();
  }
  /**
   * Handle drag end - open create modal with selected time range
   */
  handleDragEnd(e) {
    if (!this.isDragging)
      return;
    const rect = this.timelineInner.getBoundingClientRect();
    const endY = e.clientY - rect.top;
    const minY = Math.min(this.dragStartY, endY);
    const maxY = Math.max(this.dragStartY, endY);
    const minDrag = this.settings.hourHeight / 4;
    if (maxY - minY < minDrag) {
      this.cleanupDrag();
      return;
    }
    const dayIndex = Math.floor(minY / this.dayHeight) - this.visibleDaysBuffer;
    const clickedDate = new Date(this.centerDate);
    clickedDate.setDate(clickedDate.getDate() + dayIndex);
    const dayTopY = (dayIndex + this.visibleDaysBuffer) * this.dayHeight;
    const startYInDay = minY - dayTopY;
    const endYInDay = maxY - dayTopY;
    const startHours = startYInDay / this.settings.hourHeight;
    const endHours = endYInDay / this.settings.hourHeight;
    const startTime = this.roundToTimeString(startHours);
    const endTime = this.roundToTimeString(endHours);
    Logger.log("Drag selection:", clickedDate.toDateString(), startTime, "-", endTime);
    this.cleanupDrag();
    this.openCreateModalWithRange(clickedDate, startTime, endTime);
  }
  /**
   * Handle drag cancel (mouse leaves container)
   */
  handleDragCancel(_e) {
    if (this.isDragging) {
      this.cleanupDrag();
    }
  }
  // Touch versions of drag-to-create handlers
  /**
   * Handle touch start - begin selecting time range (touch version)
   */
  handleDragStartTouch(e) {
    if (e.touches.length !== 1)
      return;
    const target = e.target;
    if (target.closest(".timeline-entry-card")) {
      return;
    }
    if (this.isDragging)
      return;
    this.isDragging = true;
    if (this.selectionEl) {
      this.selectionEl.remove();
      this.selectionEl = null;
    }
    const rect = this.timelineInner.getBoundingClientRect();
    this.dragStartY = e.touches[0].clientY - rect.top;
    this.dragCurrentY = this.dragStartY;
    const dayIndex = Math.floor(this.dragStartY / this.dayHeight) - this.visibleDaysBuffer;
    this.dragStartDate = new Date(this.centerDate);
    this.dragStartDate.setDate(this.dragStartDate.getDate() + dayIndex);
    this.selectionEl = this.timelineInner.createDiv("timeline-drag-selection");
    this.dragTooltipEl = this.timelineInner.createDiv("timeline-drag-tooltip");
    this.updateSelectionElement();
    e.preventDefault();
  }
  /**
   * Handle touch move - update selection visual (touch version)
   */
  handleDragMoveTouch(e) {
    if (!this.isDragging || !this.selectionEl || e.touches.length !== 1)
      return;
    e.preventDefault();
    const rect = this.timelineInner.getBoundingClientRect();
    this.dragCurrentY = e.touches[0].clientY - rect.top;
    this.updateSelectionElement();
  }
  /**
   * Handle touch end - open create modal with selected time range (touch version)
   */
  handleDragEndTouch(e) {
    var _a;
    if (!this.isDragging)
      return;
    const touch = (_a = e.changedTouches) == null ? void 0 : _a[0];
    if (!touch) {
      this.cleanupDrag();
      return;
    }
    const rect = this.timelineInner.getBoundingClientRect();
    const endY = touch.clientY - rect.top;
    const minY = Math.min(this.dragStartY, endY);
    const maxY = Math.max(this.dragStartY, endY);
    const minDrag = this.settings.hourHeight / 4;
    if (maxY - minY < minDrag) {
      this.cleanupDrag();
      return;
    }
    const dayIndex = Math.floor(minY / this.dayHeight) - this.visibleDaysBuffer;
    const clickedDate = new Date(this.centerDate);
    clickedDate.setDate(clickedDate.getDate() + dayIndex);
    const dayTopY = (dayIndex + this.visibleDaysBuffer) * this.dayHeight;
    const startYInDay = minY - dayTopY;
    const endYInDay = maxY - dayTopY;
    const startHours = startYInDay / this.settings.hourHeight;
    const endHours = endYInDay / this.settings.hourHeight;
    const startTime = this.roundToTimeString(startHours);
    const endTime = this.roundToTimeString(endHours);
    Logger.log("Touch drag selection:", clickedDate.toDateString(), startTime, "-", endTime);
    this.cleanupDrag();
    this.openCreateModalWithRange(clickedDate, startTime, endTime);
  }
  /**
   * Handle touch cancel (touch version)
   */
  handleDragCancelTouch() {
    if (this.isDragging) {
      this.cleanupDrag();
    }
  }
  /**
   * Update the visual selection element position and tooltip
   */
  updateSelectionElement() {
    if (!this.selectionEl)
      return;
    const minY = Math.min(this.dragStartY, this.dragCurrentY);
    const maxY = Math.max(this.dragStartY, this.dragCurrentY);
    const height = Math.max(maxY - minY, 10);
    this.selectionEl.style.top = `${minY}px`;
    this.selectionEl.style.height = `${height}px`;
    if (this.dragTooltipEl) {
      const dayIndex = Math.floor(minY / this.dayHeight) - this.visibleDaysBuffer;
      const dayTopY = (dayIndex + this.visibleDaysBuffer) * this.dayHeight;
      const startYInDay = minY - dayTopY;
      const endYInDay = maxY - dayTopY;
      const startHours = startYInDay / this.settings.hourHeight;
      const endHours = endYInDay / this.settings.hourHeight;
      const startTime = this.roundToTimeString(startHours);
      const endTime = this.roundToTimeString(endHours);
      this.dragTooltipEl.setText(`${startTime} \u2013 ${endTime}`);
      this.dragTooltipEl.style.top = `${maxY + 8}px`;
    }
  }
  /**
   * Clean up drag state and selection element
   */
  cleanupDrag() {
    this.isDragging = false;
    if (this.selectionEl) {
      this.selectionEl.remove();
      this.selectionEl = null;
    }
    if (this.dragTooltipEl) {
      this.dragTooltipEl.remove();
      this.dragTooltipEl = null;
    }
    this.dragStartDate = null;
  }
  /**
   * Convert hours (decimal) to HH:mm string, rounded to 15 min
   */
  roundToTimeString(hours) {
    const totalMinutes = Math.round(hours * 60 / 15) * 15;
    const h = Math.floor(totalMinutes / 60) % 24;
    const m = totalMinutes % 60;
    return `${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
  }
  /**
   * Open create modal with pre-filled start and end times
   */
  openCreateModalWithRange(date, startTime, endTime) {
    Logger.log("Opening create modal with range:", date, startTime, "-", endTime);
    const data = {
      mode: "create",
      date,
      startTime,
      endTime
    };
    const modal = new EntryModal(
      this.app,
      this.settings,
      this.dataManager,
      data,
      () => this.refresh()
    );
    modal.open();
  }
};
var ConfirmDeleteModal = class extends import_obsidian5.Modal {
  constructor(app, entry, onConfirm) {
    super(app);
    this.entry = entry;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("time-tracker-confirm-delete");
    contentEl.createEl("h2", { text: "Delete Entry" });
    const details = contentEl.createDiv("delete-entry-details");
    details.createEl("p", {
      text: `${this.entry.start} \u2013 ${this.entry.end}`,
      cls: "delete-entry-time"
    });
    if (this.entry.description) {
      details.createEl("p", {
        text: this.entry.description,
        cls: "delete-entry-desc"
      });
    }
    contentEl.createEl("p", {
      text: "Are you sure you want to delete this entry? This cannot be undone.",
      cls: "delete-confirm-message"
    });
    const buttonContainer = contentEl.createDiv("delete-button-container");
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const deleteBtn = buttonContainer.createEl("button", {
      text: "Delete",
      cls: "mod-warning"
    });
    deleteBtn.addEventListener("click", async () => {
      await this.onConfirm();
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/ReportsView.ts
var import_obsidian8 = require("obsidian");

// src/modals/InvoiceModal.ts
var import_obsidian6 = require("obsidian");
var InvoiceModal = class extends import_obsidian6.Modal {
  constructor(app, data, onGenerate) {
    super(app);
    // Form values
    this.invoiceNumber = "";
    this.paymentTerms = "Net 30";
    this.data = data;
    this.onGenerate = onGenerate;
    this.issueDate = new Date();
    this.dueDate = this.calculateDueDate(this.issueDate, this.paymentTerms);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("invoice-modal");
    contentEl.createEl("h2", { text: "Generate Invoice" });
    const clientInfo = contentEl.createDiv("invoice-client-info");
    clientInfo.createEl("strong", { text: this.data.client.name });
    clientInfo.createEl("span", {
      text: ` \u2022 ${this.formatDateRange(this.data.periodStart, this.data.periodEnd)}`,
      cls: "invoice-period"
    });
    clientInfo.createEl("span", {
      text: ` \u2022 ${this.formatCurrency(this.data.totalAmount, this.data.client.currency)}`,
      cls: "invoice-amount"
    });
    new import_obsidian6.Setting(contentEl).setName("Invoice Number").setDesc("Unique identifier for this invoice (e.g., INV-2025-001)").addText((text5) => text5.setPlaceholder("INV-2025-001").setValue(this.invoiceNumber).onChange((value) => {
      this.invoiceNumber = value;
    }));
    new import_obsidian6.Setting(contentEl).setName("Issue Date").setDesc("Date the invoice is issued").addText((text5) => {
      text5.inputEl.type = "date";
      text5.setValue(this.formatDateForInput(this.issueDate));
      text5.onChange((value) => {
        const [year, month, day] = value.split("-").map(Number);
        this.issueDate = new Date(year, month - 1, day);
        this.updateDueDate();
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Payment Terms").setDesc("When payment is due").addDropdown((dropdown) => dropdown.addOption("Due on receipt", "Due on receipt").addOption("Net 15", "Net 15").addOption("Net 30", "Net 30").addOption("Net 45", "Net 45").addOption("Net 60", "Net 60").setValue(this.paymentTerms).onChange((value) => {
      this.paymentTerms = value;
      this.updateDueDate();
    }));
    const dueDateSetting = new import_obsidian6.Setting(contentEl).setName("Due Date").setDesc("Automatically calculated from issue date and terms");
    this.dueDateDisplay = dueDateSetting.controlEl.createDiv("invoice-due-date");
    this.dueDateDisplay.setText(this.formatDateDisplay(this.dueDate));
    const buttonRow = contentEl.createDiv("modal-button-row");
    const cancelBtn = buttonRow.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const generateBtn = buttonRow.createEl("button", {
      text: "Generate Invoice",
      cls: "mod-cta"
    });
    generateBtn.addEventListener("click", () => this.handleGenerate());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Update the due date based on issue date and terms
   */
  updateDueDate() {
    this.dueDate = this.calculateDueDate(this.issueDate, this.paymentTerms);
    if (this.dueDateDisplay) {
      this.dueDateDisplay.setText(this.formatDateDisplay(this.dueDate));
    }
  }
  /**
   * Calculate due date from issue date and payment terms
   */
  calculateDueDate(issueDate, terms) {
    const due = new Date(issueDate);
    switch (terms) {
      case "Due on receipt":
        break;
      case "Net 15":
        due.setDate(due.getDate() + 15);
        break;
      case "Net 30":
        due.setDate(due.getDate() + 30);
        break;
      case "Net 45":
        due.setDate(due.getDate() + 45);
        break;
      case "Net 60":
        due.setDate(due.getDate() + 60);
        break;
    }
    return due;
  }
  /**
   * Handle generate button click
   */
  handleGenerate() {
    if (!this.invoiceNumber.trim()) {
      new import_obsidian6.Notice("Invoice number is required");
      return;
    }
    const result = {
      invoiceNumber: this.invoiceNumber.trim(),
      issueDate: this.issueDate,
      paymentTerms: this.paymentTerms,
      dueDate: this.dueDate
    };
    this.onGenerate(result);
    this.close();
  }
  // Formatting helpers
  formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  formatDateDisplay(date) {
    return date.toLocaleDateString(void 0, {
      day: "2-digit",
      month: "2-digit",
      year: "numeric"
    });
  }
  formatDateRange(start, end) {
    const options = {
      month: "short",
      day: "numeric",
      year: "numeric"
    };
    return `${start.toLocaleDateString(void 0, { month: "short", day: "numeric" })} - ${end.toLocaleDateString(void 0, options)}`;
  }
  formatCurrency(amount, currency) {
    return new Intl.NumberFormat(void 0, {
      style: "currency",
      currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  }
};

// src/invoice/InvoiceGenerator.ts
var import_obsidian7 = require("obsidian");
var InvoiceGenerator = class {
  constructor(app, settings, dataManager) {
    this.app = app;
    this.settings = settings;
    this.dataManager = dataManager;
  }
  /**
   * Generate invoice data from filtered entries
   */
  generateInvoiceData(entries, client, modalResult, rangeStart, rangeEnd) {
    var _a;
    const projectHours = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      if (entry.client !== client.id)
        continue;
      const effectiveMinutes = this.dataManager.getEffectiveDuration(entry, rangeStart, rangeEnd);
      if (effectiveMinutes <= 0)
        continue;
      const projectName = entry.project || "(No Project)";
      const current = projectHours.get(projectName) || 0;
      projectHours.set(projectName, current + effectiveMinutes);
    }
    const lineItems = [];
    for (const [projectName, minutes] of projectHours) {
      const hours = minutes / 60;
      const project = this.settings.projects.find(
        (p) => (p.name === projectName || p.id === projectName) && p.clientId === client.id
      );
      const hourlyRate = (_a = project == null ? void 0 : project.rateOverride) != null ? _a : client.rate;
      const amount = hours * hourlyRate;
      const description = projectName;
      lineItems.push({
        description,
        quantity: Math.round(hours * 100) / 100,
        // Round to 2 decimals
        unitPrice: hourlyRate,
        currency: client.currency,
        amount: Math.round(amount * 100) / 100
      });
    }
    lineItems.sort((a, b) => b.amount - a.amount);
    const subtotal = lineItems.reduce((sum, item) => sum + item.amount, 0);
    const total = subtotal;
    return {
      invoiceNumber: modalResult.invoiceNumber,
      issueDate: modalResult.issueDate,
      dueDate: modalResult.dueDate,
      billFrom: this.settings.billFrom,
      billTo: {
        name: client.name,
        address: client.address || ""
      },
      lineItems,
      currency: client.currency,
      subtotal: Math.round(subtotal * 100) / 100,
      total: Math.round(total * 100) / 100
    };
  }
  /**
   * Generate markdown content from invoice data
   */
  generateMarkdown(invoice) {
    const lines = [];
    lines.push(`# ${invoice.invoiceNumber}`);
    lines.push("");
    lines.push(`Issue date: ${this.formatDate(invoice.issueDate)}`);
    lines.push(`Due date: ${this.formatDate(invoice.dueDate)}`);
    lines.push("");
    const billFromAddress = invoice.billFrom.address.split("\n").filter((l) => l.trim());
    const billToAddress = invoice.billTo.address.split("\n").filter((l) => l.trim());
    lines.push('<div style="display: flex; justify-content: space-between; margin: 20px 0;">');
    lines.push('<div style="flex: 1;">');
    lines.push("<small>Bill from</small><br>");
    lines.push(`<strong>${this.escapeHtml(invoice.billFrom.name)}</strong><br>`);
    for (const line of billFromAddress) {
      lines.push(`${this.escapeHtml(line)}<br>`);
    }
    lines.push("</div>");
    lines.push('<div style="flex: 1; text-align: right;">');
    lines.push("<small>Bill to</small><br>");
    lines.push(`<strong>${this.escapeHtml(invoice.billTo.name)}</strong><br>`);
    for (const line of billToAddress) {
      lines.push(`${this.escapeHtml(line)}<br>`);
    }
    lines.push("</div>");
    lines.push("</div>");
    lines.push("");
    lines.push('<table style="width: 100%; border-collapse: collapse; margin: 20px 0;">');
    lines.push("<thead>");
    lines.push('<tr style="border-bottom: 1px solid #ccc;">');
    lines.push('<th style="text-align: left; padding: 8px 0;">DESCRIPTION</th>');
    lines.push('<th style="text-align: right; padding: 8px 0;">QUANTITY</th>');
    lines.push('<th style="text-align: right; padding: 8px 0;">UNIT PRICE</th>');
    lines.push('<th style="text-align: right; padding: 8px 0;">AMOUNT</th>');
    lines.push("</tr>");
    lines.push("</thead>");
    lines.push("<tbody>");
    for (const item of invoice.lineItems) {
      const quantity = item.quantity.toFixed(2);
      const unitPrice = this.formatAmount(item.unitPrice, item.currency);
      const amount = this.formatAmount(item.amount, item.currency);
      let description = item.description;
      if (description === "(No Project)") {
        description = "Services";
      }
      lines.push('<tr style="border-bottom: 1px solid #eee;">');
      lines.push(`<td style="text-align: left; padding: 8px 0;">${this.escapeHtml(description)}</td>`);
      lines.push(`<td style="text-align: right; padding: 8px 0;">${quantity}</td>`);
      lines.push(`<td style="text-align: right; padding: 8px 0;">${unitPrice}</td>`);
      lines.push(`<td style="text-align: right; padding: 8px 0;">${amount}</td>`);
      lines.push("</tr>");
    }
    lines.push("</tbody>");
    lines.push("</table>");
    lines.push("");
    const subtotalFormatted = this.formatAmount(invoice.subtotal, invoice.currency);
    const totalFormatted = this.formatAmount(invoice.total, invoice.currency);
    lines.push('<div style="text-align: right; margin-top: 20px;">');
    lines.push(`<div>SUBTOTAL: ${subtotalFormatted}</div>`);
    lines.push(`<div><strong>TOTAL: ${totalFormatted}</strong></div>`);
    lines.push("</div>");
    lines.push("");
    return lines.join("\n");
  }
  escapeHtml(text5) {
    return text5.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  /**
   * Save invoice to file
   */
  async saveInvoice(invoice, markdown) {
    await this.ensureInvoiceFolder();
    const filename = `${this.sanitizeFilename(invoice.invoiceNumber)}.md`;
    const filepath = `${this.settings.invoiceFolder}/${filename}`;
    const existing = this.app.vault.getAbstractFileByPath(filepath);
    if (existing) {
      throw new Error(`Invoice file already exists: ${filepath}`);
    }
    await this.app.vault.create(filepath, markdown);
    Logger.log("InvoiceGenerator: Created invoice at", filepath);
    return filepath;
  }
  /**
   * Ensure the invoice folder exists
   */
  async ensureInvoiceFolder() {
    const folderPath = this.settings.invoiceFolder;
    const existing = this.app.vault.getAbstractFileByPath(folderPath);
    if (existing instanceof import_obsidian7.TFolder) {
      return;
    }
    await this.app.vault.createFolder(folderPath);
    Logger.log("InvoiceGenerator: Created invoice folder", folderPath);
  }
  // Formatting helpers
  formatDate(date) {
    const day = String(date.getDate()).padStart(2, "0");
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
  }
  formatAmount(amount, currency) {
    return `${amount.toLocaleString(void 0, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} ${currency}`;
  }
  escapeTableCell(text5) {
    return text5.replace(/\|/g, "\\|");
  }
  sanitizeFilename(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-");
  }
};

// src/views/ReportsView.ts
var MAX_REPORT_DAYS = 90;
var ReportsView = class extends import_obsidian8.ItemView {
  constructor(leaf, settings, dataManager) {
    super(leaf);
    // Current report state
    this.selectedPreset = "this-week";
    this.customStartDate = null;
    this.customEndDate = null;
    this.projectReports = [];
    this.activityReports = [];
    this.clientReports = [];
    this.totalMinutes = 0;
    // Store current entries and date range for invoice generation
    this.currentEntries = [];
    this.currentRangeStart = null;
    this.currentRangeEnd = null;
    // Expanded clients (for project breakdown)
    this.expandedClients = /* @__PURE__ */ new Set();
    // Expanded projects within clients (key: "clientId:projectName")
    this.expandedClientProjects = /* @__PURE__ */ new Set();
    this.settings = settings;
    this.dataManager = dataManager;
  }
  getViewType() {
    return VIEW_TYPE_REPORTS;
  }
  getDisplayText() {
    return "Reports";
  }
  getIcon() {
    return "pie-chart";
  }
  async onOpen() {
    await this.render();
    await this.loadReport();
  }
  async onClose() {
  }
  updateSettings(settings) {
    this.settings = settings;
    this.loadReport();
  }
  async refresh() {
    await this.loadReport();
  }
  /**
   * Main render function
   */
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("time-tracker-reports");
    this.renderHeader(container);
    this.contentContainer = container.createDiv("reports-content");
    this.rangeSelector = this.contentContainer.createDiv("reports-range-selector");
    this.renderRangeSelector();
    this.customDateInputs = this.contentContainer.createDiv("reports-custom-dates");
    this.customDateInputs.style.display = "none";
    this.renderCustomDateInputs();
    this.summaryContainer = this.contentContainer.createDiv("reports-summary");
    this.reportsContainer = this.contentContainer.createDiv("reports-table-container");
    this.activityContainer = this.contentContainer.createDiv("reports-table-container");
    this.clientContainer = this.contentContainer.createDiv("reports-table-container");
  }
  /**
   * Render the header
   */
  renderHeader(container) {
    const header = container.createDiv("reports-header");
    const titleSection = header.createDiv("reports-header-title");
    titleSection.createEl("h2", { text: "Time Reports" });
    const controls = header.createDiv("reports-header-controls");
    const exportCsvBtn = controls.createEl("button", {
      text: "Export CSV",
      cls: "reports-btn"
    });
    exportCsvBtn.addEventListener("click", () => this.exportToCSV());
    const exportJsonBtn = controls.createEl("button", {
      text: "Export JSON",
      cls: "reports-btn"
    });
    exportJsonBtn.addEventListener("click", () => this.exportToJSON());
    const refreshBtn = controls.createEl("button", {
      text: "Refresh",
      cls: "reports-btn"
    });
    refreshBtn.addEventListener("click", () => this.loadReport());
  }
  /**
   * Render time range preset buttons
   */
  renderRangeSelector() {
    this.rangeSelector.empty();
    const presets = [
      { value: "today", label: "Today" },
      { value: "yesterday", label: "Yesterday" },
      { value: "this-week", label: "This Week" },
      { value: "last-week", label: "Last Week" },
      { value: "this-month", label: "This Month" },
      { value: "last-month", label: "Last Month" },
      { value: "custom", label: "Custom" }
    ];
    for (const preset of presets) {
      const btn = this.rangeSelector.createEl("button", {
        text: preset.label,
        cls: `reports-range-btn ${this.selectedPreset === preset.value ? "is-active" : ""}`
      });
      btn.addEventListener("click", () => this.selectPreset(preset.value));
    }
  }
  /**
   * Render custom date inputs
   */
  renderCustomDateInputs() {
    this.customDateInputs.empty();
    const startLabel = this.customDateInputs.createEl("label", { text: "From: " });
    const startInput = startLabel.createEl("input", { type: "date" });
    if (this.customStartDate) {
      startInput.value = TableParser.getDateString(this.customStartDate);
    }
    startInput.addEventListener("change", (e) => {
      this.customStartDate = new Date(e.target.value);
      this.loadReport();
    });
    const endLabel = this.customDateInputs.createEl("label", { text: "To: " });
    const endInput = endLabel.createEl("input", { type: "date" });
    if (this.customEndDate) {
      endInput.value = TableParser.getDateString(this.customEndDate);
    }
    endInput.addEventListener("change", (e) => {
      this.customEndDate = new Date(e.target.value);
      this.loadReport();
    });
  }
  /**
   * Select a time range preset
   */
  selectPreset(preset) {
    this.selectedPreset = preset;
    this.renderRangeSelector();
    if (preset === "custom") {
      this.customDateInputs.style.display = "flex";
      if (!this.customStartDate || !this.customEndDate) {
        const { start, end } = this.getDateRange("this-week");
        this.customStartDate = start;
        this.customEndDate = end;
        this.renderCustomDateInputs();
      }
    } else {
      this.customDateInputs.style.display = "none";
    }
    this.loadReport();
  }
  /**
   * Get date range for a preset
   */
  getDateRange(preset) {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    switch (preset) {
      case "today":
        return {
          start: today,
          end: new Date(today.getTime() + 24 * 60 * 60 * 1e3 - 1)
        };
      case "yesterday": {
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        const yesterdayEnd = new Date(yesterday);
        yesterdayEnd.setHours(23, 59, 59, 999);
        return { start: yesterday, end: yesterdayEnd };
      }
      case "this-week": {
        const dayOfWeek = today.getDay();
        const mondayOffset = this.settings.weekStart === "monday" ? dayOfWeek === 0 ? -6 : 1 - dayOfWeek : -dayOfWeek;
        const weekStart = new Date(today);
        weekStart.setDate(today.getDate() + mondayOffset);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        return { start: weekStart, end: weekEnd };
      }
      case "last-week": {
        const dayOfWeek = today.getDay();
        const mondayOffset = this.settings.weekStart === "monday" ? dayOfWeek === 0 ? -6 : 1 - dayOfWeek : -dayOfWeek;
        const thisWeekStart = new Date(today);
        thisWeekStart.setDate(today.getDate() + mondayOffset);
        const lastWeekStart = new Date(thisWeekStart);
        lastWeekStart.setDate(thisWeekStart.getDate() - 7);
        const lastWeekEnd = new Date(lastWeekStart);
        lastWeekEnd.setDate(lastWeekStart.getDate() + 6);
        lastWeekEnd.setHours(23, 59, 59, 999);
        return { start: lastWeekStart, end: lastWeekEnd };
      }
      case "this-month": {
        const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
        const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        monthEnd.setHours(23, 59, 59, 999);
        return { start: monthStart, end: monthEnd };
      }
      case "last-month": {
        const lastMonthStart = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
        lastMonthEnd.setHours(23, 59, 59, 999);
        return { start: lastMonthStart, end: lastMonthEnd };
      }
      case "custom": {
        const customStart = this.customStartDate || today;
        const customEnd = this.customEndDate || today;
        const customEndEOD = new Date(customEnd);
        customEndEOD.setHours(23, 59, 59, 999);
        return { start: customStart, end: customEndEOD };
      }
      default: {
        const defaultEnd = new Date(today);
        defaultEnd.setHours(23, 59, 59, 999);
        return { start: today, end: defaultEnd };
      }
    }
  }
  /**
   * Load report data for the selected time range
   */
  async loadReport() {
    const { start, end } = this.getDateRange(this.selectedPreset);
    const daysDiff = Math.ceil((end.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24));
    if (daysDiff > MAX_REPORT_DAYS) {
      new import_obsidian8.Notice(`Report range limited to ${MAX_REPORT_DAYS} days for performance. Please select a shorter range.`);
      return;
    }
    Logger.log("ReportsView: Loading report for", start.toDateString(), "to", end.toDateString());
    const entries = await this.dataManager.loadDateRange(start, end);
    Logger.log("ReportsView: Found", entries.length, "entries");
    this.currentEntries = entries;
    this.currentRangeStart = start;
    this.currentRangeEnd = end;
    this.calculateReports(entries, start, end);
    this.calculateActivityReports(entries, start, end);
    this.calculateClientReports(entries, start, end);
    this.renderSummary(start, end);
    this.renderClientTable();
  }
  /**
   * Calculate project and activity reports from entries
   * Uses effective duration to handle midnight-spanning entries correctly
   */
  calculateReports(entries, rangeStart, rangeEnd) {
    const projectMap = /* @__PURE__ */ new Map();
    this.totalMinutes = 0;
    for (const entry of entries) {
      const effectiveMinutes = this.dataManager.getEffectiveDuration(entry, rangeStart, rangeEnd);
      if (effectiveMinutes <= 0)
        continue;
      const projectName = entry.project || "(No Project)";
      if (!projectMap.has(projectName)) {
        projectMap.set(projectName, { minutes: 0, activityMap: /* @__PURE__ */ new Map() });
      }
      const projectData = projectMap.get(projectName);
      projectData.minutes += effectiveMinutes;
      this.totalMinutes += effectiveMinutes;
      const activityName = entry.activity || "(No Activity)";
      const current = projectData.activityMap.get(activityName) || 0;
      projectData.activityMap.set(activityName, current + effectiveMinutes);
    }
    this.projectReports = [];
    for (const [projectName, data] of projectMap) {
      const projectColor = this.getProjectColor(projectName);
      const percentage = this.totalMinutes > 0 ? data.minutes / this.totalMinutes * 100 : 0;
      const activityBreakdown = [];
      for (const [activityName, activityMinutes] of data.activityMap) {
        const activityColor = this.getActivityColor(activityName);
        activityBreakdown.push({
          activity: activityName,
          color: activityColor,
          totalMinutes: activityMinutes,
          percentageOfProject: data.minutes > 0 ? activityMinutes / data.minutes * 100 : 0
        });
      }
      activityBreakdown.sort((a, b) => b.totalMinutes - a.totalMinutes);
      this.projectReports.push({
        project: projectName,
        color: projectColor,
        totalMinutes: data.minutes,
        percentage,
        activityBreakdown
      });
    }
    this.projectReports.sort((a, b) => b.totalMinutes - a.totalMinutes);
  }
  /**
   * Calculate activity reports from entries
   * Activities are mutually exclusive so percentages add up to 100%
   */
  calculateActivityReports(entries, rangeStart, rangeEnd) {
    const activityMap = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      const effectiveMinutes = this.dataManager.getEffectiveDuration(entry, rangeStart, rangeEnd);
      if (effectiveMinutes <= 0)
        continue;
      const activityName = entry.activity || "(No Activity)";
      const current = activityMap.get(activityName) || 0;
      activityMap.set(activityName, current + effectiveMinutes);
    }
    this.activityReports = [];
    for (const [activityName, minutes] of activityMap) {
      const activityColor = this.getActivityColor(activityName);
      const percentage = this.totalMinutes > 0 ? minutes / this.totalMinutes * 100 : 0;
      this.activityReports.push({
        activity: activityName,
        name: activityName,
        color: activityColor,
        totalMinutes: minutes,
        percentage
      });
    }
    this.activityReports.sort((a, b) => b.totalMinutes - a.totalMinutes);
  }
  /**
   * Render the summary section
   */
  renderSummary(start, end) {
    this.summaryContainer.empty();
    const rangeLabel = this.summaryContainer.createDiv("reports-range-label");
    rangeLabel.setText(this.formatDateRange(start, end));
    const totalCard = this.summaryContainer.createDiv("reports-total-card");
    totalCard.createDiv({ text: "Total Time", cls: "reports-total-label" });
    totalCard.createDiv({ text: this.formatDuration(this.totalMinutes), cls: "reports-total-value" });
    const projectCard = this.summaryContainer.createDiv("reports-summary-card");
    projectCard.createDiv({ text: "Projects", cls: "reports-summary-label" });
    projectCard.createDiv({ text: String(this.projectReports.length), cls: "reports-summary-value" });
    const clientCard = this.summaryContainer.createDiv("reports-summary-card");
    clientCard.createDiv({ text: "Clients", cls: "reports-summary-label" });
    clientCard.createDiv({ text: String(this.clientReports.length), cls: "reports-summary-value" });
  }
  /**
   * Calculate client reports from entries
   * Groups time by client (using entry.client directly)
   */
  calculateClientReports(entries, rangeStart, rangeEnd) {
    if (this.settings.clients.length === 0) {
      this.clientReports = [];
      return;
    }
    const clientMap = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      const effectiveMinutes = this.dataManager.getEffectiveDuration(entry, rangeStart, rangeEnd);
      if (effectiveMinutes <= 0)
        continue;
      const projectName = entry.project || "(No Project)";
      const activityName = entry.activity || "(No Activity)";
      const clientId = entry.client;
      if (!clientMap.has(clientId)) {
        clientMap.set(clientId, { minutes: 0, projects: /* @__PURE__ */ new Map() });
      }
      const clientData = clientMap.get(clientId);
      clientData.minutes += effectiveMinutes;
      if (!clientData.projects.has(projectName)) {
        clientData.projects.set(projectName, { minutes: 0, activities: /* @__PURE__ */ new Map() });
      }
      const projectData = clientData.projects.get(projectName);
      projectData.minutes += effectiveMinutes;
      const currentActivityMinutes = projectData.activities.get(activityName) || 0;
      projectData.activities.set(activityName, currentActivityMinutes + effectiveMinutes);
    }
    this.clientReports = [];
    let totalClientMinutes = 0;
    for (const [, data] of clientMap) {
      totalClientMinutes += data.minutes;
    }
    for (const [clientId, data] of clientMap) {
      const client = this.settings.clients.find((c) => c.id === clientId);
      if (!client)
        continue;
      const percentage = totalClientMinutes > 0 ? data.minutes / totalClientMinutes * 100 : 0;
      const billableAmount = client.rate * (data.minutes / 60);
      const projectBreakdown = [];
      for (const [projectName, projectData] of data.projects) {
        const projectColor = this.getProjectColor(projectName);
        const activityBreakdown = [];
        for (const [activityName, activityMinutes] of projectData.activities) {
          activityBreakdown.push({
            activity: activityName,
            color: this.getActivityColor(activityName),
            totalMinutes: activityMinutes,
            percentageOfProject: projectData.minutes > 0 ? activityMinutes / projectData.minutes * 100 : 0
          });
        }
        activityBreakdown.sort((a, b) => b.totalMinutes - a.totalMinutes);
        projectBreakdown.push({
          project: projectName,
          color: projectColor,
          totalMinutes: projectData.minutes,
          percentage: data.minutes > 0 ? projectData.minutes / data.minutes * 100 : 0,
          activityBreakdown
        });
      }
      projectBreakdown.sort((a, b) => b.totalMinutes - a.totalMinutes);
      this.clientReports.push({
        clientId,
        name: client.name,
        color: client.color,
        rate: client.rate,
        currency: client.currency,
        totalMinutes: data.minutes,
        billableAmount,
        percentage,
        projectBreakdown
      });
    }
    this.clientReports.sort((a, b) => b.totalMinutes - a.totalMinutes);
  }
  /**
   * Render the client breakdown table (Client â†’ Project â†’ Activity hierarchy)
   */
  renderClientTable() {
    var _a;
    this.clientContainer.empty();
    if (this.clientReports.length === 0) {
      this.clientContainer.createDiv({
        text: "No time entries found for this period.",
        cls: "reports-empty"
      });
      return;
    }
    const table = this.clientContainer.createEl("table", { cls: "reports-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "Client / Project / Activity" });
    headerRow.createEl("th", { text: "Hours", cls: "reports-col-hours" });
    headerRow.createEl("th", { text: "Billable", cls: "reports-col-billable" });
    headerRow.createEl("th", { text: "%", cls: "reports-col-percent" });
    headerRow.createEl("th", { text: "", cls: "reports-col-bar" });
    const tbody = table.createEl("tbody");
    for (const report of this.clientReports) {
      const row = tbody.createEl("tr", { cls: "reports-client-row" });
      row.addEventListener("click", () => this.toggleClientExpand(report.clientId));
      const nameCell = row.createEl("td", { cls: "reports-client-name" });
      const colorDot = nameCell.createSpan("reports-color-dot");
      colorDot.style.backgroundColor = report.color;
      const expandIcon = nameCell.createSpan("reports-expand-icon");
      expandIcon.setText(this.expandedClients.has(report.clientId) ? "\u25BC" : "\u25B6");
      nameCell.createSpan({ text: report.name });
      if (report.totalMinutes > 0) {
        const invoiceBtn = nameCell.createEl("button", {
          text: "Invoice",
          cls: "reports-invoice-btn"
        });
        invoiceBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.openInvoiceModal(report.clientId, report.billableAmount);
        });
      }
      row.createEl("td", {
        text: this.formatDuration(report.totalMinutes),
        cls: "reports-col-hours"
      });
      row.createEl("td", {
        text: this.formatCurrency(report.billableAmount, report.currency),
        cls: "reports-col-billable"
      });
      row.createEl("td", {
        text: `${report.percentage.toFixed(1)}%`,
        cls: "reports-col-percent"
      });
      const barCell = row.createEl("td", { cls: "reports-col-bar" });
      const bar = barCell.createDiv("reports-bar");
      bar.style.width = `${report.percentage}%`;
      bar.style.backgroundColor = report.color;
      if (this.expandedClients.has(report.clientId)) {
        for (const projectReport of report.projectBreakdown) {
          const projectKey = `${report.clientId}:${projectReport.project}`;
          const projectExpanded = this.expandedClientProjects.has(projectKey);
          const hasActivities = projectReport.activityBreakdown.length > 0;
          const projectRow = tbody.createEl("tr", { cls: "reports-project-nested-row" });
          if (hasActivities) {
            projectRow.addEventListener("click", (e) => {
              e.stopPropagation();
              this.toggleProjectExpand(projectKey);
            });
          }
          const projectNameCell = projectRow.createEl("td", { cls: "reports-project-nested-name" });
          const projectDot = projectNameCell.createSpan("reports-color-dot");
          projectDot.style.backgroundColor = projectReport.color;
          if (hasActivities) {
            const projectExpandIcon = projectNameCell.createSpan("reports-expand-icon");
            projectExpandIcon.setText(projectExpanded ? "\u25BC" : "\u25B6");
          }
          projectNameCell.createSpan({ text: projectReport.project });
          projectRow.createEl("td", {
            text: this.formatDuration(projectReport.totalMinutes),
            cls: "reports-col-hours"
          });
          projectRow.createEl("td", { cls: "reports-col-billable" });
          projectRow.createEl("td", {
            text: `${projectReport.percentage.toFixed(1)}%`,
            cls: "reports-col-percent"
          });
          const projectBarCell = projectRow.createEl("td", { cls: "reports-col-bar" });
          const projectBar = projectBarCell.createDiv("reports-bar reports-bar-nested");
          projectBar.style.width = `${projectReport.percentage}%`;
          projectBar.style.backgroundColor = projectReport.color;
          if (projectExpanded && hasActivities) {
            for (const activityReport of projectReport.activityBreakdown) {
              const activityRow = tbody.createEl("tr", { cls: "reports-activity-nested-row" });
              const activityNameCell = activityRow.createEl("td", { cls: "reports-activity-nested-name" });
              const activityDot = activityNameCell.createSpan("reports-color-dot");
              activityDot.style.backgroundColor = activityReport.color;
              activityNameCell.createSpan({ text: activityReport.activity });
              activityRow.createEl("td", {
                text: this.formatDuration(activityReport.totalMinutes),
                cls: "reports-col-hours"
              });
              activityRow.createEl("td", { cls: "reports-col-billable" });
              activityRow.createEl("td", {
                text: `${activityReport.percentageOfProject.toFixed(1)}%`,
                cls: "reports-col-percent"
              });
              const activityBarCell = activityRow.createEl("td", { cls: "reports-col-bar" });
              const activityBar = activityBarCell.createDiv("reports-bar reports-bar-activity");
              activityBar.style.width = `${activityReport.percentageOfProject}%`;
              activityBar.style.backgroundColor = activityReport.color;
            }
          }
        }
      }
    }
    const totalRow = tbody.createEl("tr", { cls: "reports-total-row" });
    totalRow.createEl("td", { text: "Total", cls: "reports-total-label" });
    let totalMinutes = 0;
    let totalBillable = 0;
    for (const report of this.clientReports) {
      totalMinutes += report.totalMinutes;
      totalBillable += report.billableAmount;
    }
    totalRow.createEl("td", {
      text: this.formatDuration(totalMinutes),
      cls: "reports-col-hours"
    });
    const currency = ((_a = this.clientReports[0]) == null ? void 0 : _a.currency) || "USD";
    totalRow.createEl("td", {
      text: this.formatCurrency(totalBillable, currency),
      cls: "reports-col-billable"
    });
    totalRow.createEl("td", { text: "", cls: "reports-col-percent" });
    totalRow.createEl("td", { text: "", cls: "reports-col-bar" });
  }
  /**
   * Toggle client expansion to show/hide project breakdown
   */
  toggleClientExpand(clientId) {
    if (this.expandedClients.has(clientId)) {
      this.expandedClients.delete(clientId);
    } else {
      this.expandedClients.add(clientId);
    }
    this.renderClientTable();
  }
  toggleProjectExpand(projectKey) {
    if (this.expandedClientProjects.has(projectKey)) {
      this.expandedClientProjects.delete(projectKey);
    } else {
      this.expandedClientProjects.add(projectKey);
    }
    this.renderClientTable();
  }
  /**
   * Open the invoice modal for a client
   */
  openInvoiceModal(clientId, totalAmount) {
    const client = this.settings.clients.find((c) => c.id === clientId);
    if (!client) {
      new import_obsidian8.Notice("Client not found");
      return;
    }
    if (!this.currentRangeStart || !this.currentRangeEnd) {
      new import_obsidian8.Notice("No date range selected");
      return;
    }
    const modalData = {
      client,
      periodStart: this.currentRangeStart,
      periodEnd: this.currentRangeEnd,
      totalAmount
    };
    const modal = new InvoiceModal(
      this.app,
      modalData,
      async (result) => {
        await this.generateInvoice(client, result);
      }
    );
    modal.open();
  }
  /**
   * Generate the invoice file
   */
  async generateInvoice(client, modalResult) {
    if (!this.currentRangeStart || !this.currentRangeEnd) {
      new import_obsidian8.Notice("No date range selected");
      return;
    }
    try {
      const generator = new InvoiceGenerator(this.app, this.settings, this.dataManager);
      const invoiceData = generator.generateInvoiceData(
        this.currentEntries,
        client,
        modalResult,
        this.currentRangeStart,
        this.currentRangeEnd
      );
      const markdown = generator.generateMarkdown(invoiceData);
      const filepath = await generator.saveInvoice(invoiceData, markdown);
      new import_obsidian8.Notice(`Invoice created: ${filepath}`);
      const file = this.app.vault.getAbstractFileByPath(filepath);
      if (file) {
        await this.app.workspace.getLeaf().openFile(file);
      }
    } catch (error) {
      Logger.log("ReportsView: Error generating invoice", error);
      new import_obsidian8.Notice(`Error generating invoice: ${error.message}`);
    }
  }
  // Helper methods
  formatDuration(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    if (hours === 0)
      return `${mins}m`;
    if (mins === 0)
      return `${hours}h`;
    return `${hours}h ${mins}m`;
  }
  formatCurrency(amount, currency) {
    return new Intl.NumberFormat(void 0, {
      style: "currency",
      currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  }
  formatDateRange(start, end) {
    const sameDay = start.toDateString() === end.toDateString();
    const options = {
      month: "short",
      day: "numeric",
      year: "numeric"
    };
    if (sameDay) {
      return start.toLocaleDateString(void 0, options);
    }
    return `${start.toLocaleDateString(void 0, { month: "short", day: "numeric" })} - ${end.toLocaleDateString(void 0, options)}`;
  }
  getProjectColor(projectName) {
    if (projectName === "(No Project)")
      return "#666";
    const project = this.settings.projects.find((p) => p.name === projectName || p.id === projectName);
    return (project == null ? void 0 : project.color) || "#4f46e5";
  }
  getActivityColor(activityName) {
    if (activityName === "(No Activity)")
      return "#666";
    const activity = this.settings.activities.find((a) => a.name === activityName || a.id === activityName);
    return (activity == null ? void 0 : activity.color) || "#f59e0b";
  }
  /**
   * Export current report data to CSV
   */
  async exportToCSV() {
    const { start, end } = this.getDateRange(this.selectedPreset);
    const entries = await this.dataManager.loadDateRange(start, end);
    if (entries.length === 0) {
      Logger.log("ReportsView: No entries to export");
      return;
    }
    const csv = this.generateCSV(entries);
    const startStr = TableParser.getDateString(start);
    const endStr = TableParser.getDateString(end);
    const filename = `time-entries-${startStr}-to-${endStr}.csv`;
    this.downloadCSV(csv, filename);
  }
  /**
   * Generate CSV content from time entries
   */
  generateCSV(entries) {
    const headers = ["Start", "End", "Duration", "Description", "Client", "Project", "Activity", "Notes"];
    const sorted = [...entries].sort(
      (a, b) => a.startDateTime.getTime() - b.startDateTime.getTime()
    );
    const rows = [headers];
    for (const entry of sorted) {
      const client = this.settings.clients.find((c) => c.id === entry.client);
      const clientName = (client == null ? void 0 : client.name) || entry.client;
      const row = [
        TableParser.formatDateTime(entry.startDateTime),
        TableParser.formatDateTime(entry.endDateTime),
        this.formatDuration(entry.durationMinutes),
        entry.description || "",
        clientName,
        entry.project || "",
        entry.activity || "",
        entry.linkedNote || ""
      ];
      rows.push(row);
    }
    return rows.map(
      (row) => row.map((cell) => this.escapeCSVCell(cell)).join(",")
    ).join("\n");
  }
  /**
   * Escape a cell value for CSV format
   */
  escapeCSVCell(value) {
    if (value.includes(",") || value.includes('"') || value.includes("\n")) {
      return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
  }
  /**
   * Trigger browser download of CSV file
   */
  downloadCSV(content3, filename) {
    const blob = new Blob([content3], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link2 = document.createElement("a");
    link2.href = url;
    link2.download = filename;
    link2.style.display = "none";
    document.body.appendChild(link2);
    link2.click();
    document.body.removeChild(link2);
    URL.revokeObjectURL(url);
    Logger.log("ReportsView: Exported CSV -", filename);
  }
  /**
   * Export current report data to JSON
   */
  async exportToJSON() {
    const { start, end } = this.getDateRange(this.selectedPreset);
    const entries = await this.dataManager.loadDateRange(start, end);
    if (entries.length === 0) {
      new import_obsidian8.Notice("No entries to export");
      return;
    }
    const json = this.generateJSON(entries, start, end);
    const startStr = TableParser.getDateString(start);
    const endStr = TableParser.getDateString(end);
    const filename = `time-entries-${startStr}-to-${endStr}.json`;
    this.downloadJSON(json, filename);
  }
  /**
   * Generate JSON content from time entries
   */
  generateJSON(entries, start, end) {
    const sorted = [...entries].sort(
      (a, b) => a.startDateTime.getTime() - b.startDateTime.getTime()
    );
    const exportData = {
      exportedAt: new Date().toISOString(),
      dateRange: {
        start: TableParser.getDateString(start),
        end: TableParser.getDateString(end)
      },
      totalEntries: sorted.length,
      entries: sorted.map((entry) => ({
        date: entry.date,
        start: entry.start,
        end: entry.end,
        durationMinutes: entry.durationMinutes,
        description: entry.description,
        client: entry.client,
        project: entry.project || null,
        activity: entry.activity || null,
        linkedNote: entry.linkedNote || null
      }))
    };
    return JSON.stringify(exportData, null, 2);
  }
  /**
   * Trigger browser download of JSON file
   */
  downloadJSON(content3, filename) {
    const blob = new Blob([content3], { type: "application/json;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link2 = document.createElement("a");
    link2.href = url;
    link2.download = filename;
    link2.style.display = "none";
    document.body.appendChild(link2);
    link2.click();
    document.body.removeChild(link2);
    URL.revokeObjectURL(url);
    Logger.log("ReportsView: Exported JSON -", filename);
  }
};

// main.ts
var WhereDidTheTimeGoPlugin = class extends import_obsidian9.Plugin {
  async onload() {
    console.log("Loading Where Did The Time Go plugin");
    await this.loadSettings();
    Logger.setDebugMode(this.settings.debugMode);
    this.dataManager = new DataManager(this.app.vault, this.settings);
    this.registerView(
      VIEW_TYPE_TIMELINE,
      (leaf) => new TimelineView(leaf, this.settings, this.dataManager)
    );
    this.registerView(
      VIEW_TYPE_REPORTS,
      (leaf) => new ReportsView(leaf, this.settings, this.dataManager)
    );
    this.addRibbonIcon("clock", "Open Timeline", () => {
      this.activateTimelineView();
    });
    this.addRibbonIcon("pie-chart", "Open Reports", () => {
      this.activateReportsView();
    });
    this.addCommand({
      id: "open-timeline",
      name: "Open Timeline",
      callback: () => {
        this.activateTimelineView();
      }
    });
    this.addCommand({
      id: "open-reports",
      name: "Open Reports",
      callback: () => {
        this.activateReportsView();
      }
    });
    this.addCommand({
      id: "create-entry",
      name: "Create Time Entry",
      callback: () => {
        this.openCreateEntryModal();
      }
    });
    this.addSettingTab(new TimeTrackerSettingTab(this.app, this));
    const debouncedRefresh = (0, import_obsidian9.debounce)(() => this.refreshTimelineViews(), 500, true);
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file.path.startsWith(this.settings.timeTrackingFolder)) {
          const monthMatch = file.name.match(/^(\d{4}-\d{2})\.md$/);
          if (monthMatch) {
            this.dataManager.invalidateMonth(monthMatch[1]);
            debouncedRefresh();
          }
        }
      })
    );
  }
  onunload() {
    console.log("Unloading Where Did The Time Go plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    Logger.setDebugMode(this.settings.debugMode);
    if (this.dataManager) {
      this.dataManager.updateSettings(this.settings);
    }
    this.refreshTimelineViews();
  }
  /**
   * Activate or focus the timeline view
   */
  async activateTimelineView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMELINE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_TIMELINE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * Activate or focus the reports view
   */
  async activateReportsView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_REPORTS);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_REPORTS,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * Open the create entry modal directly (for command palette)
   */
  openCreateEntryModal() {
    const now = new Date();
    const minutes = Math.floor(now.getMinutes() / 15) * 15;
    const startTime = `${now.getHours().toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
    const modal = new EntryModal(
      this.app,
      this.settings,
      this.dataManager,
      {
        mode: "create",
        date: now,
        startTime
      },
      () => this.refreshTimelineViews()
    );
    modal.open();
  }
  /**
   * Refresh all open timeline views
   */
  refreshTimelineViews() {
    const timelineLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMELINE);
    for (const leaf of timelineLeaves) {
      const view = leaf.view;
      if (view && view.updateSettings) {
        view.updateSettings(this.settings);
      }
    }
    const reportsLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_REPORTS);
    for (const leaf of reportsLeaves) {
      const view = leaf.view;
      if (view && view.updateSettings) {
        view.updateSettings(this.settings);
      }
    }
  }
};
